// This function was written me (omg!) to get the first offset of the desired type.
// Small utility to make my life easier modifying effects inside item headers
DEFINE_PATCH_FUNCTION get_first_offset_type
    INT_VAR
        type = 1
    RET
        type_offset
BEGIN
    READ_SHORT 0x68 abilities_num
    READ_LONG 0x64 curr_offset
    FOR ( ability = 0; ability < abilities_num; ++ability ) BEGIN
        PATCH_IF (BYTE_AT curr_offset) = type BEGIN
            SET type_offset = curr_offset
            ability = abilities_num // i.e. break
        END
        SET curr_offset += 0x38
    END
END

DEFINE_PATCH_FUNCTION get_first_offset_type_containing_op
INT_VAR
    opcode = "-1"
BEGIN
    PATCH_IF opcode < 0 OR opcode > 367 BEGIN
        PATCH_FAIL "Opcode %opcode% is invalid. Valid range: [0-367]"
    END ELSE BEGIN
        READ_SHORT 0x68 abilities_num
        READ_LONG 0x64 curr_offset
        FOR ( ability = 0; ability < abilities_num; ++ability ) BEGIN
            PATCH_IF (BYTE_AT curr_offset) = type BEGIN
                SET type_offset = curr_offset
               // READ_
                ability = abilities_num // i.e. break
            END
            SET curr_offset += 0x38
        END
    END
END

// get the offset in the first item effect
DEFINE_PATCH_FUNCTION itm_first_offset_effect
    RET
        offset
BEGIN
    READ_SHORT 0x68 abilities_num
    READ_SHORT 0x70 global_eff_num
    READ_LONG 0x64 curr_offset
    SET offset = curr_offset + (abilities_num * 0x38) + (global_eff_num * 0x30)
END

// get the offset in the first spell effect
DEFINE_PATCH_FUNCTION spl_first_offset_effect
    RET
        offset
BEGIN
    READ_SHORT 0x68 abilities_num
    READ_SHORT 0x70 global_eff_num
    READ_LONG 0x64 curr_offset
    SET offset = curr_offset + (abilities_num * 0x28) + (global_eff_num * 0x30)
END

DEFINE_PATCH_FUNCTION last_consecutive_header
INT_VAR
    type = "-1"
RET
    result
BEGIN
    READ_LONG 0x64 ability_offset
    READ_SHORT 0x68 num_abilities

    PATCH_IF num_abilities > 1 BEGIN // #1 if there's at least more than one header to look at...
        READ_SHORT (ability_offset + 0x10) first_casting_level // first header casting level
        READ_SHORT (ability_offset + 0x28 + 0x10) next_casting_level // first scaling header (i.e. second one)
        PATCH_IF (next_casting_level - first_casting_level) = 1 BEGIN // #2 if the diff between both is one, let's continue...
           // PATCH_IF num_abilities > 2 BEGIN // #3 if we have more headers to examine, let's continue...
                SET found = 0
                FOR ( h = 2; h < num_abilities; ++h ) BEGIN
                    READ_SHORT (ability_offset + (0x28 * h) + 0x10) curr_casting_level
                    PATCH_IF curr_casting_level - next_casting_level > 1 BEGIN // #4 if the diff is more than one, we found it
                        SET result = h - 1
                        h = num_abilities + 1 // i.e. break
                        found = 1
                    END
                    SET next_casting_level = curr_casting_level
                END
                PATCH_IF found = 0 BEGIN
                    SET result = num_abilities - 1
                END
            //END ELSE BEGIN // #3 otherwise, the last valid header in question is the previous one: the second header
             //   SET result = 1
            //END
        END ELSE BEGIN // #2 otherwise, the last valid header in question is the previous one: the first header
            SET result = 0
        END
    END ELSE BEGIN // #1 otherwise, the last valid header will be the first one, or none if none are present
        SET result = num_abilities - 1 // -1 if no headers are present, 0 if only one header is present
    END
END




