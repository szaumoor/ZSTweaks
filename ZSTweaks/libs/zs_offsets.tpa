// This function was written me (omg!) to get the first offset of the desired type.
// Small utility to make my life easier modifying effects inside item headers
DEFINE_PATCH_FUNCTION get_first_offset_type
    INT_VAR
        type = 1
    RET
        type_offset
BEGIN
    READ_SHORT 0x68 abilities_num
    READ_LONG 0x64 curr_offset
    FOR ( ability = 0; ability < abilities_num; ++ability ) BEGIN
        PATCH_IF (BYTE_AT curr_offset) = type BEGIN
            SET type_offset = curr_offset
            ability = abilities_num // i.e. break
        END
        SET curr_offset += 0x38
    END
END

DEFINE_PATCH_FUNCTION get_first_offset_type_containing_op
INT_VAR
    opcode = "-1"
BEGIN
    PATCH_IF opcode < 0 OR opcode > 367 BEGIN
        PATCH_FAIL "Opcode %opcode% is invalid. Valid range: [0-367]"
    END ELSE BEGIN
        READ_SHORT 0x68 abilities_num
        READ_LONG 0x64 curr_offset
        FOR ( ability = 0; ability < abilities_num; ++ability ) BEGIN
            PATCH_IF (BYTE_AT curr_offset) = type BEGIN
                SET type_offset = curr_offset
               // READ_
                ability = abilities_num // i.e. break
            END
            SET curr_offset += 0x38
        END
    END
END

// get the offset in the first item effect
DEFINE_PATCH_FUNCTION itm_first_offset_effect
    RET
        offset
BEGIN
    READ_SHORT 0x68 abilities_num
    READ_SHORT 0x70 global_eff_num
    READ_LONG 0x64 curr_offset
    SET offset = curr_offset + (abilities_num * 0x38) + (global_eff_num * 0x30)
END

// get the offset in the first spell effect
DEFINE_PATCH_FUNCTION spl_first_offset_effect
    RET
        offset
BEGIN
    READ_SHORT 0x68 abilities_num
    READ_SHORT 0x70 global_eff_num
    READ_LONG 0x64 curr_offset
    SET offset = curr_offset + (abilities_num * 0x28) + (global_eff_num * 0x30)
END

DEFINE_PATCH_FUNCTION last_consecutive_header
INT_VAR
    type = "-1"
RET
    result
BEGIN
    READ_LONG 0x64 ability_offset
    READ_SHORT 0x68 num_abilities

    PATCH_IF num_abilities > 1 BEGIN // if looping is needed
        READ_SHORT (ability_offset + 0x28 + 0x10) first_casting_level // minimum level at first scaling header (i.e. second one)
      //  PATCH_PRINT "First casting level is %first_casting_level%"
        PATCH_IF num_abilities > 2 BEGIN
            FOR ( h = 2; h < num_abilities; ++h ) BEGIN
                READ_SHORT (ability_offset + (0x28 * h) + 0x10) curr_casting_level
                //PATCH_PRINT "Current casting level is %curr_casting_level%"
                PATCH_IF curr_casting_level - first_casting_level > 1 BEGIN
                    SET result = h - 1
                    h = num_abilities + 1 // i.e. break
                  //  PATCH_PRINT "Looks like the the last valid header is %result%"
                END
                SET first_casting_level = curr_casting_level
            END
        END ELSE BEGIN
            SET result = 1
        END
    END ELSE BEGIN
        SET result = num_abilities - 1 // -1 if no headers are present, 0 if only one header is present
    END
END




