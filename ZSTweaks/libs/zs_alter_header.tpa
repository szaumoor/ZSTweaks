/////                                                  \\\\\
///// cd_string_set_from_tra                           \\\\\
/////                                                  \\\\\

// this function process a tra file into string_sets based on the tra reference, e.g. @123 is used as STRING_SET 123 @123
// this function creates headers and does basic duration extensions to level 30; written for inwd-in-bg2 ages ago
DEFINE_ACTION_FUNCTION cd_string_set_from_tra
  INT_VAR cd_mode    = 1  // set to 0 will generate tph files; 1 will build and execute them
  STR_VAR input_tra  = ~~ // tra file to process
          output_tph = ~~ // tph being built; use weidu_external for this
BEGIN

  ACTION_IF FILE_EXISTS ~%input_tra%~ BEGIN // skip sod for non-bgee

<<<<<<<<./inlined/blank.txt
>>>>>>>>
    COPY ~./inlined/blank.txt~ ~%output_tph%~

    ACTION_IF !cd_mode BEGIN

      APPEND_OUTER ~%output_tph%~ "// this file is automatically generated by SECRET COMPONENT 999 from %input_tra% - there is no need to manually update it"

    END

    APPEND_OUTER ~%output_tph%~ "WITH_TRA ~%input_tra%~ BEGIN STRING_SET"

    COPY ~%input_tra%~ ~%input_tra%~
      REPLACE_EVALUATE ~^\([ %TAB%]*@\)\([0-9]+\)\([ %TAB%]*=\)~ BEGIN
        INNER_ACTION BEGIN
          APPEND_OUTER ~%output_tph%~ ~  %MATCH2% @%MATCH2%~
        END
      END ~%MATCH1%%MATCH2%%MATCH3%~
      BUT_ONLY

    APPEND_OUTER ~%output_tph%~ ~END~

    ACTION_IF cd_mode BEGIN

      INCLUDE ~%output_tph%~

    END

  END

END

/////                                                  \\\\\
///// alter_header                                     \\\\\
/////                                                  \\\\\

// got tired of crappy ALTER_ITEM_HEADER and ALTER_SPELL_HEADER
DEFINE_PATCH_FUNCTION ALTER_HEADER

  // defines what we're going to check
  INT_VAR multi_match         = 999
          verbose             = 0
          silent              = 0
          header              = "-1"

  // variables for finding the effect to match
          match_type        = "-1"
          match_location    = "-1"
          match_target      = "-1"
          match_target_num  = "-1"
          match_range       = "-1"
          match_speed       = "-1"
          match_projectile  = "-1"
          // spell headers only
          match_level       = "-1"
          // item headers only
          match_identify       = "-1"
          match_alt_dicesize   = "-1"
          match_launcher       = "-1"
          match_alt_dicenumber = "-1"
          match_alt_damage     = "-1"
          match_to_hit         = "-1"
          match_dicesize       = "-1"
          match_primary        = "-1"
          match_dicenumber     = "-1"
          match_secondary      = "-1"
          match_damage         = "-1"
          match_damage_type    = "-1"
          match_charges        = "-1"
          match_drained        = "-1"
          match_overhand       = "-1"
          match_backhand       = "-1"
          match_thrust         = "-1"
          match_arrow          = "-1"
          match_bolt           = "-1"
          match_bullet         = "-1"
          // flags at 0x26 (still item only)
          match_flag_strength      = "-1" // add strength bonus, bit0
          match_flag_break         = "-1" // breakable, bit1
          match_flag_str_damage    = "-1" // strength damage bonus, ee, bit2
          match_flag_str_to_hit    = "-1" // strength thac0 bonus, ee, bit3
          match_flag_hostile       = "-1" // hostile, bit10
          match_flag_recharge      = "-1" // recharge after resting, bit11
          match_flag_bypass        = "-1" // bypass armor, bit16
          match_flag_keenedge      = "-1" // keen edge, bit17
          match_flag_backstab      = "-1" // tobex only, toggle backstab, bit25
          match_flag_noinvisible   = "-1" // tobex only, cannot target invisible, bit26

  // variables for the new effect
          type        = "-1"
          location    = "-1"
          target      = "-1"
          target_num  = "-1"
          range       = "-1"
          speed       = "-1"
          projectile  = "-1"
          // spell headers only
          level       = "-1"
          // item headers only
          identify       = "-1"
          alt_dicesize   = "-1"
          launcher       = "-1"
          alt_dicenumber = "-1"
          alt_damage     = "-1"
          to_hit         = "-1"
          dicesize       = "-1"
          primary        = "-1"
          dicenumber     = "-1"
          secondary      = "-1"
          damage         = "-1"
          damage_type    = "-1"
          charges        = "-1"
          drained        = "-1"
          overhand       = "-1"
          backhand       = "-1"
          thrust         = "-1"
          arrow          = "-1"
          bolt           = "-1"
          bullet         = "-1"
          // flags at 0x26
          flag_strength      = "-1" // add strength bonus, bit0
          flag_break         = "-1" // breakable, bit1
          flag_str_damage    = "-1" // strength damage bonus, ee, bit2
          flag_str_to_hit    = "-1" // strength thac0 bonus, ee, bit3
          flag_hostile       = "-1" // hostile, bit10
          flag_recharge      = "-1" // recharge after resting, bit11
          flag_bypass        = "-1" // bypass armor, bit16
          flag_keenedge      = "-1" // keen edge, bit17
          flag_backstab      = "-1" // tobex only, toggle backstab, bit25
          flag_noinvisible   = "-1" // tobex only, cannot target invisible, bit26

  // same for match and new STR_VAR
  STR_VAR match_icon      = "SAME"
          icon            = "SAME"
BEGIN

  READ_ASCII 0x00 sig (3)
  SET abil_length = 0
  SET proceed = 0
  SET alter = 0
  PATCH_IF ("%sig%" STRING_COMPARE_CASE "ITM" = 0) BEGIN
    SET abil_length = 0x38
  END ELSE
  PATCH_IF ("%sig%" STRING_COMPARE_CASE "SPL" = 0) BEGIN
    SET abil_length = 0x28
  END
  PATCH_IF abil_length = 0 BEGIN
    PATCH_WARN ~WARNING: file type not recognized on %SOURCE_FILE% for ALTER_HEADER macro.~
  END ELSE BEGIN
    SET pro_off = abil_length = 0x38 ? 0x2a : 0x26
    READ_LONG   0x64 abil_off
    READ_SHORT  0x68 abil_num
    FOR (index = 0 ; index < abil_num ; ++index) BEGIN
      PATCH_IF ((header < 0) OR (header = index)) BEGIN
        SET base = abil_off + (index * abil_length)
        READ_BYTE  (base + 0x00) o_type
        READ_BYTE  (base + 0x02) o_location
        READ_ASCII (base + 0x04) o_icon (8) NULL
        READ_BYTE  (base + 0x0c) o_target
        READ_BYTE  (base + 0x0d) o_target_num
        READ_SHORT (base + 0x0e) o_range
        READ_SHORT (base + pro_off) o_projectile
        PATCH_IF abil_length = 0x38 BEGIN
          // item headers only
          READ_BYTE  (base + 0x01) o_identify
          READ_BYTE  (base + 0x03) o_alt_dicesize
          READ_BYTE  (base + 0x10) o_launcher
          READ_BYTE  (base + 0x11) o_alt_dicenumber
          READ_BYTE  (base + 0x12) o_speed
          READ_BYTE  (base + 0x13) o_alt_damage
          READ_SHORT (base + 0x14) o_to_hit
          READ_BYTE  (base + 0x16) o_dicesize
          READ_BYTE  (base + 0x17) o_primary
          READ_BYTE  (base + 0x18) o_dicenumber
          READ_BYTE  (base + 0x19) o_secondary
          READ_SHORT (base + 0x1a) o_damage
          READ_SHORT (base + 0x1c) o_damage_type
          READ_SHORT (base + 0x22) o_charges
          READ_SHORT (base + 0x24) o_drained
          READ_LONG  (base + 0x26) o_flags
          READ_SHORT (base + 0x2c) o_overhand
          READ_SHORT (base + 0x2e) o_backhand
          READ_SHORT (base + 0x30) o_thrust
          READ_SHORT (base + 0x32) o_arrow
          READ_SHORT (base + 0x34) o_bolt
          READ_SHORT (base + 0x36) o_bullet
        END ELSE BEGIN
          READ_SHORT (base + 0x10) o_level
          READ_SHORT (base + 0x12) o_speed
        END
        // now check our header vs. the match variables
        PATCH_IF ((multi_match != 0) AND
                  ((match_type       = o_type)       OR (match_type < 0))       AND
                  ((match_type       = o_type)       OR (match_type < 0))       AND
                  ((match_location   = o_location)   OR (match_location < 0))   AND
                  ((match_target     = o_target)     OR (match_target < 0))     AND
                  ((match_target_num = o_target_num) OR (match_target_num < 0)) AND
                  ((match_range      = o_range)      OR (match_range < 0))      AND
                  ((match_speed      = o_speed)      OR (match_speed < 0))      AND
                  ((match_projectile = o_projectile) OR (match_projectile < 0)) AND
                  (("%match_icon%" STRING_COMPARE_CASE "%o_icon%" = 0) OR ("%match_icon%" STRING_COMPARE_CASE "SAME" = 0))) BEGIN
          PATCH_IF (abil_length = 0x38) BEGIN  // item-specific checks
            PATCH_IF (((match_identify       = o_identify)       OR (match_identify < 0))       AND
                      ((match_alt_dicesize   = o_alt_dicesize)   OR (match_alt_dicesize < 0))   AND
                      ((match_launcher       = o_launcher)       OR (match_launcher < 0))       AND
                      ((match_alt_dicenumber = o_alt_dicenumber) OR (match_alt_dicenumber < 0)) AND
                      ((match_alt_damage     = o_alt_damage)     OR (match_alt_damage < 0))     AND
                      ((match_to_hit         = o_to_hit)         OR (match_to_hit < 0))         AND
                      ((match_dicesize       = o_dicesize)       OR (match_dicesize < 0))       AND
                      ((match_primary        = o_primary)        OR (match_primary < 0))        AND
                      ((match_dicenumber     = o_dicenumber)     OR (match_dicenumber < 0))     AND
                      ((match_secondary      = o_secondary)      OR (match_secondary < 0))      AND
                      ((match_damage         = o_damage)         OR (match_damage < 0))         AND
                      ((match_damage_type    = o_damage_type)    OR (match_damage_type < 0))    AND
                      ((match_charges        = o_charges)        OR (match_charges < 0))        AND
                      ((match_drained        = o_drained)        OR (match_drained < 0))        AND
                      ((match_overhand       = o_overhand)       OR (match_overhand < 0))       AND
                      ((match_backhand       = o_backhand)       OR (match_backhand < 0))       AND
                      ((match_thrust         = o_thrust)         OR (match_thrust < 0))         AND
                      ((match_arrow          = o_arrow)          OR (match_arrow < 0))          AND
                      ((match_bolt           = o_bolt)           OR (match_bolt < 0))           AND
                      ((match_bullet         = o_bullet)         OR (match_bullet < 0))         AND
                      ((match_flag_strength < 0) OR
                       (match_flag_strength = (flags & BIT0)) OR // not set
                       (match_flag_strength > 0 AND (flags & BIT0) = BIT0)) AND
                      ((match_flag_break < 0) OR
                       (match_flag_break = (flags & BIT1)) OR // not set
                       (match_flag_break > 0 AND (flags & BIT1) = BIT1)) AND
                      ((match_flag_str_damage < 0) OR
                       (match_flag_str_damage = (flags & BIT2)) OR // not set
                       (match_flag_str_damage > 0 AND (flags & BIT2) = BIT2)) AND
                      ((match_flag_str_to_hit < 0) OR
                       (match_flag_str_to_hit = (flags & BIT3)) OR // not set
                       (match_flag_str_to_hit > 0 AND (flags & BIT3) = BIT3)) AND
                      ((match_flag_hostile < 0) OR
                       (match_flag_hostile = (flags & BIT10)) OR // not set
                       (match_flag_hostile > 0 AND (flags & BIT10) = BIT10)) AND
                      ((match_flag_recharge < 0) OR
                       (match_flag_recharge = (flags & BIT11)) OR // not set
                       (match_flag_recharge > 0 AND (flags & BIT11) = BIT11)) AND
                      ((match_flag_bypass < 0) OR
                       (match_flag_bypass = (flags & BIT16)) OR // not set
                       (match_flag_bypass > 0 AND (flags & BIT16) = BIT16)) AND
                      ((match_flag_keenedge < 0) OR
                       (match_flag_keenedge = (flags & BIT17)) OR // not set
                       (match_flag_keenedge > 0 AND (flags & BIT17) = BIT17)) AND
                      ((match_flag_backstab < 0) OR
                       (match_flag_backstab = (flags & BIT25)) OR // not set
                       (match_flag_backstab > 0 AND (flags & BIT25) = BIT25)) AND
                      ((match_flag_noinvisible < 0) OR
                       (match_flag_noinvisible = (flags & BIT26)) OR // not set
                       (match_flag_noinvisible > 0 AND (flags & BIT26) = BIT26))) BEGIN
              SET proceed = 1
            END
          END ELSE BEGIN // spell-specific checks
            PATCH_IF ((match_level = o_level) OR (match_level < 0)) BEGIN
              SET proceed = 1
            END
          END
          PATCH_IF proceed BEGIN
            SET alter += 1
            SET multi_match -= 1
            PATCH_IF (type >= 0)       BEGIN WRITE_BYTE  (base + 0x00) type END
            PATCH_IF (location >= 0)   BEGIN WRITE_BYTE  (base + 0x02) location END
            PATCH_IF (target >= 0)     BEGIN WRITE_BYTE  (base + 0x0c) target END
            PATCH_IF (target_num >= 0) BEGIN WRITE_BYTE  (base + 0x0d) target_num END
            PATCH_IF (range >= 0)      BEGIN WRITE_SHORT (base + 0x0e) range END
            PATCH_IF (projectile >= 0) BEGIN WRITE_SHORT (base + pro_off) projectile END
            PATCH_IF ("%icon%" STRING_COMPARE_CASE "SAME") BEGIN WRITE_ASCIIE (base + 0x04) ~%icon%~ #8 END
            PATCH_IF abil_length = 0x38 BEGIN // item headers
              PATCH_IF (identify >= 0)       BEGIN WRITE_BYTE  (base + 0x01) identify       END
              PATCH_IF (alt_dicesize >= 0)   BEGIN WRITE_BYTE  (base + 0x03) alt_dicesize   END
              PATCH_IF (launcher >= 0)       BEGIN WRITE_BYTE  (base + 0x10) launcher       END
              PATCH_IF (alt_dicenumber >= 0) BEGIN WRITE_BYTE  (base + 0x11) alt_dicenumber END
              PATCH_IF (speed >= 0)          BEGIN WRITE_BYTE  (base + 0x12) speed          END
              PATCH_IF (alt_damage >= 0)     BEGIN WRITE_BYTE  (base + 0x13) alt_damage     END
              PATCH_IF (to_hit >= 0)         BEGIN WRITE_SHORT (base + 0x14) to_hit         END
              PATCH_IF (dicesize >= 0)       BEGIN WRITE_BYTE  (base + 0x16) dicesize       END
              PATCH_IF (primary >= 0)        BEGIN WRITE_BYTE  (base + 0x17) primary        END
              PATCH_IF (dicenumber >= 0)     BEGIN WRITE_BYTE  (base + 0x18) dicenumber     END
              PATCH_IF (secondary >= 0)      BEGIN WRITE_BYTE  (base + 0x19) secondary      END
              PATCH_IF (damage >= 0)         BEGIN WRITE_SHORT (base + 0x1a) damage         END
              PATCH_IF (damage_type >= 0)    BEGIN WRITE_SHORT (base + 0x1c) damage_type    END
              PATCH_IF (charges >= 0)        BEGIN WRITE_SHORT (base + 0x22) charges        END
              PATCH_IF (drained >= 0)        BEGIN WRITE_SHORT (base + 0x24) drained        END
              PATCH_IF (overhand >= 0)       BEGIN WRITE_SHORT (base + 0x2c) overhand       END
              PATCH_IF (backhand >= 0)       BEGIN WRITE_SHORT (base + 0x2e) backhand       END
              PATCH_IF (thrust >= 0)         BEGIN WRITE_SHORT (base + 0x30) thrust         END
              PATCH_IF (arrow >= 0)          BEGIN WRITE_SHORT (base + 0x32) arrow          END
              PATCH_IF (bolt >= 0)           BEGIN WRITE_SHORT (base + 0x34) bolt           END
              PATCH_IF (bullet >= 0)         BEGIN WRITE_SHORT (base + 0x36) bullet         END

              PATCH_IF (flag_strength = 0)    BEGIN WRITE_LONG (base + 0x26) (THIS &  `BIT0)  END
              PATCH_IF (flag_strength > 0)    BEGIN WRITE_LONG (base + 0x26) (THIS BOR BIT0)  END
              PATCH_IF (flag_break = 0)       BEGIN WRITE_LONG (base + 0x26) (THIS &  `BIT1)  END
              PATCH_IF (flag_break > 0)       BEGIN WRITE_LONG (base + 0x26) (THIS BOR BIT1)  END
              PATCH_IF (flag_str_damage = 0)  BEGIN WRITE_LONG (base + 0x26) (THIS &  `BIT2)  END
              PATCH_IF (flag_str_damage > 0)  BEGIN WRITE_LONG (base + 0x26) (THIS BOR BIT2)  END
              PATCH_IF (flag_str_to_hit = 0)  BEGIN WRITE_LONG (base + 0x26) (THIS &  `BIT3)  END
              PATCH_IF (flag_str_to_hit > 0)  BEGIN WRITE_LONG (base + 0x26) (THIS BOR BIT3)  END
              PATCH_IF (flag_hostile = 0)     BEGIN WRITE_LONG (base + 0x26) (THIS &  `BIT10) END
              PATCH_IF (flag_hostile > 0)     BEGIN WRITE_LONG (base + 0x26) (THIS BOR BIT10) END
              PATCH_IF (flag_recharge = 0)    BEGIN WRITE_LONG (base + 0x26) (THIS &  `BIT11) END
              PATCH_IF (flag_recharge > 0)    BEGIN WRITE_LONG (base + 0x26) (THIS BOR BIT11) END
              PATCH_IF (flag_bypass = 0)      BEGIN WRITE_LONG (base + 0x26) (THIS &  `BIT16) END
              PATCH_IF (flag_bypass > 0)      BEGIN WRITE_LONG (base + 0x26) (THIS BOR BIT16) END
              PATCH_IF (flag_keenedge = 0)    BEGIN WRITE_LONG (base + 0x26) (THIS &  `BIT17) END
              PATCH_IF (flag_keenedge > 0)    BEGIN WRITE_LONG (base + 0x26) (THIS BOR BIT17) END
              PATCH_IF (flag_backstab = 0)    BEGIN WRITE_LONG (base + 0x26) (THIS &  `BIT25) END
              PATCH_IF (flag_backstab > 0)    BEGIN WRITE_LONG (base + 0x26) (THIS BOR BIT25) END
              PATCH_IF (flag_noinvisible = 0) BEGIN WRITE_LONG (base + 0x26) (THIS &  `BIT26) END
              PATCH_IF (flag_noinvisible > 0) BEGIN WRITE_LONG (base + 0x26) (THIS BOR BIT26) END
            END ELSE BEGIN // spell headers
              PATCH_IF (level >= 0) BEGIN WRITE_SHORT (base + 0x10) level END
              PATCH_IF (speed >= 0) BEGIN WRITE_SHORT (base + 0x12) speed END
            END
          END // proceed check
        END // mutual fields check
      END // for loop
    END // header check
  END // abil_length check

  PATCH_IF (alter = 0 && !silent) BEGIN
    PATCH_WARN "WARNING: no effects altered on %SOURCE_FILE% via ALTER_HEADER"
  END

  PATCH_IF (verbose && !silent) BEGIN
    READ_LONG 0x0c strref
    PATCH_IF ((strref > 0) AND (strref < 200000)) BEGIN
      READ_STRREF 0x0c name
    END ELSE BEGIN
      READ_STRREF 0x08 name
    END
    PATCH_PRINT "              ~%SOURCE_FILE%~   ~override~ // %name%, %alter% effect(s) altered"
  END

END

/////                                                  \\\\\
///// ALTER_AREA/CREATURE_ITEM                         \\\\\
/////                                                  \\\\\

// alter_creature and alter_area just feed into a common macro that does the work

DEFINE_PATCH_FUNCTION ALTER_AREA_ITEM

  // defines what we're going to check
  INT_VAR expiry           = "-1"
          charge1          = "-1"
          charge2          = "-1"
          charge3          = "-1"
          flags            = "-1"
          flag_identified  = "-1"
          flag_unstealable = "-1"
          flag_stolen      = "-1"
          flag_undroppable = "-1"
  STR_VAR item       = "same"
          match_item = "same"

BEGIN

  READ_SHORT 0x76 item_num ELSE 0
  READ_LONG  0x78 item_off ELSE 0
  LPF ALTER_AREA-CREATURE_ITEM INT_VAR expiry charge1 charge2 charge3 flags flag_identified flag_unstealable flag_stolen flag_undroppable item_num item_off
                               STR_VAR item match_item END

END

DEFINE_PATCH_FUNCTION ALTER_CREATURE_ITEM

  // defines what we're going to check
  INT_VAR expiry           = "-1"
          charge1          = "-1"
          charge2          = "-1"
          charge3          = "-1"
          flags            = "-1"
          flag_identified  = "-1"
          flag_unstealable = "-1"
          flag_stolen      = "-1"
          flag_undroppable = "-1"
  STR_VAR item       = "same"
          match_item = "same"

BEGIN

  READ_LONG  0x2bc item_off ELSE 0
  READ_LONG  0x2c0 item_num ELSE 0
  LPF ALTER_AREA-CREATURE_ITEM INT_VAR expiry charge1 charge2 charge3 flags flag_identified flag_unstealable flag_stolen flag_undroppable item_num item_off
                               STR_VAR item match_item END

END

DEFINE_PATCH_FUNCTION ALTER_AREA-CREATURE_ITEM

  // defines what we're going to check
  INT_VAR expiry           = "-1"
          charge1          = "-1"
          charge2          = "-1"
          charge3          = "-1"
          flags            = "-1"
          flag_identified  = "-1"
          flag_unstealable = "-1"
          flag_stolen      = "-1"
          flag_undroppable = "-1"
          item_num         = 0
          item_off         = 0
  STR_VAR item       = "same"
          match_item = "same"

BEGIN

  FOR (index = 0 ; index < item_num ; ++index) BEGIN
    SET base = (item_off + (index * 0x14))
    READ_ASCII base o_item
    PATCH_IF (("%o_item%" STRING_COMPARE_CASE "%match_item%" = 0) OR
              ("all"      STRING_COMPARE_CASE "%match_item%" = 0)) BEGIN
      PATCH_IF (expiry >= 0)  BEGIN WRITE_SHORT (base + 0x08) expiry END
      PATCH_IF (charge1 >= 0) BEGIN WRITE_SHORT (base + 0x0a) charge1 END
      PATCH_IF (charge2 >= 0) BEGIN WRITE_SHORT (base + 0x0c) charge2 END
      PATCH_IF (charge3 >= 0) BEGIN WRITE_SHORT (base + 0x0e) charge3 END
      PATCH_IF (flags >= 0)   BEGIN
        WRITE_LONG (base + 0x10) flags
      END ELSE BEGIN // only check individual flags if overall value not given
        PATCH_IF (flag_identified = 0)  BEGIN WRITE_LONG  (base + 0x10) (THIS & `BIT0) END
        PATCH_IF (flag_identified = 1)  BEGIN WRITE_LONG  (base + 0x10) (THIS BOR BIT0) END
        PATCH_IF (flag_unstealable = 0) BEGIN WRITE_LONG  (base + 0x10) (THIS & `BIT1) END
        PATCH_IF (flag_unstealable = 1) BEGIN WRITE_LONG  (base + 0x10) (THIS BOR BIT1) END
        PATCH_IF (flag_stolen = 0)      BEGIN WRITE_LONG  (base + 0x10) (THIS & `BIT2) END
        PATCH_IF (flag_stolen = 1)      BEGIN WRITE_LONG  (base + 0x10) (THIS BOR BIT2) END
        PATCH_IF (flag_undroppable = 0) BEGIN WRITE_LONG  (base + 0x10) (THIS & `BIT3) END
        PATCH_IF (flag_undroppable = 1) BEGIN WRITE_LONG  (base + 0x10) (THIS BOR BIT3) END
      END
      PATCH_IF ("%item%" STRING_COMPARE_CASE "same") BEGIN
        WRITE_ASCIIE base ~%item%~ #8
      END
    END
  END

END

/////                                                  \\\\\
///// miscellaneous creature inventory macros          \\\\\
/////                                                  \\\\\

// this function takes an item listed in a creture file and moves it to an open slot
// it'll try the appropriate slot first and then move to inventory
DEFINE_PATCH_FUNCTION cd_equip_item

  // defines what we're going to check
  INT_VAR move = 0
          gpuse = 0
  STR_VAR item = "same"
          slot = "helmet"

BEGIN

  SET fruitbats = "-1"
  PATCH_IF ("%slot%" STRING_COMPARE_CASE "helmet" = 0) BEGIN
    SET start = 0
  END ELSE
  PATCH_IF ("%slot%" STRING_COMPARE_CASE "armor" = 0) BEGIN
    SET start = 1
  END ELSE
  PATCH_IF ("%slot%" STRING_COMPARE_CASE "shield" = 0) BEGIN
    SET start = 2
  END ELSE
  PATCH_IF ("%slot%" STRING_COMPARE_CASE "gloves" = 0) BEGIN
    SET start = 3
  END ELSE
  PATCH_IF ("%slot%" STRING_COMPARE_CASE "rings" = 0) BEGIN
    SET start = 4
    SET fruitbats = 5
  END ELSE
  PATCH_IF ("%slot%" STRING_COMPARE_CASE "amulet" = 0) BEGIN
    SET start = 6
  END ELSE
  PATCH_IF ("%slot%" STRING_COMPARE_CASE "jewelry" = 0) BEGIN
    SET start = 4
    SET fruitbats = 6
  END ELSE
  PATCH_IF ("%slot%" STRING_COMPARE_CASE "belt" = 0) BEGIN
    SET start = 7
  END ELSE
  PATCH_IF ("%slot%" STRING_COMPARE_CASE "boots" = 0) BEGIN
    SET start = 8
  END ELSE
  PATCH_IF ("%slot%" STRING_COMPARE_CASE "weapon" = 0) BEGIN
    SET start = 9
    SET fruitbats = 12
  END ELSE
  PATCH_IF ("%slot%" STRING_COMPARE_CASE "quiver" = 0) BEGIN
    SET start = 13
    SET fruitbats = 15
  END ELSE
  PATCH_IF ("%slot%" STRING_COMPARE_CASE "quickslot" = 0) BEGIN
    SET start = 18
    SET fruitbats = 20
  END ELSE BEGIN // inventory
    PATCH_IF gpuse = 0 BEGIN // creatures with gpuse scripts will try to use items in the first inventory slots
      SET start = 21
    END ELSE BEGIN
      SET start = 23
    END
    SET fruitbats = 0
  END
  PATCH_IF fruitbats < 0 BEGIN SET fruitbats = start END

  READ_LONG  0x2b8 slot_off ELSE 0
  READ_LONG  0x2bc itm_off ELSE 0
  READ_LONG  0x2c0 itm_num ELSE 0
  FOR (index = 0 ; index < itm_num ; ++index) BEGIN
    READ_ASCII (itm_off + (0x14 * index)) test_item
    PATCH_IF ("%item%" STRING_COMPARE_CASE "%test_item%" = 0) BEGIN
      SET proceed = 1
      FOR (index2 = 0 ; index2 < 36 ; ++index2) BEGIN // first make a loop to make sure it's not assigned somwhere already
        READ_SHORT (slot_off + (index2 * 0x02)) ref
        PATCH_IF ref = index BEGIN
          PATCH_IF move = 1 BEGIN
            WRITE_SHORT (slot_off + (index2 * 0x02)) 0xffff
          END ELSE BEGIN
            SET proceed = 0
          END
        END
      END
      PATCH_IF proceed BEGIN
        FOR (index2 = start ; index2 < 36 ; ++index2) BEGIN // first make a loop to make sure it's not assigned somwhere already
          READ_SHORT (slot_off + (index2 * 0x02)) ref
          PATCH_IF (ref = 0xffff) BEGIN // if null reference in targeted slot
            WRITE_SHORT (slot_off + (index2 * 0x02)) index // adds reference to item
            SET index2 = 36 // kills loop
          END
          PATCH_IF (index2 = fruitbats) BEGIN // if end of possible equipment slots, skip ahead to inventory
            PATCH_IF gpuse = 0 BEGIN // creatures with gpuse scripts will try to use items in the first inventory slots
              SET index2 = 20 // otherwise go to inventory slots
            END ELSE BEGIN
              SET index2 = 22 // otherwise go to inventory slots
            END
          END
        END
      END
    END
  END

END

// run this on creatures with invalid selected weapons; it'll check the weapon slots and update the equipped weapon as needed
DEFINE_PATCH_FUNCTION cd_equip_weapon BEGIN

  READ_LONG  0x2b8 slot_off ELSE 0
  READ_LONG  0x2c0 itm_num  ELSE 0
  WRITE_SHORT (slot_off + 0x4c) 0xffff // null equipped weapon - either patch below will enter a valid value, or no valid value exists
  FOR (index = 0 ; index < 4 ; ++index) BEGIN // search through weapon slots
    READ_SHORT (slot_off + 0x12 + (index * 0x02)) ref
    PATCH_IF ((ref != 0xffff) AND (ref < itm_num)) BEGIN // if valid reference in weapon slots
//    PATCH_IF (ref != 0xffff) BEGIN // if valid reference in weapon slots
      WRITE_SHORT (slot_off + 0x4c) index // equipped weapon
      SET "index" = 4 // kills loop and prevents next patch_if
    END
  END

END

// run this on creatures with invalid selected weapons; it'll check the weapon slots and update the equipped weapon as needed
DEFINE_PATCH_FUNCTION cd_equip_weapon_specific

  // defines what we're going to check
  STR_VAR item = ""

BEGIN


  READ_LONG  0x2b8 slot_off
  READ_LONG  0x2bc itm_off
  FOR (index = 0; index < 4; ++index) BEGIN // cycles through weapon slots
    READ_SHORT (slot_off + 0x12 + (index * 0x02)) slot_num
    PATCH_IF (slot_num < 37) BEGIN
      READ_ASCII (itm_off + (slot_num * 0x14)) weapon
      PATCH_IF ("%item%" STRING_COMPARE_CASE "%weapon%" = 0) BEGIN // if long sword
        WRITE_SHORT (slot_off + 0x4c) index // sets weapon slot to selected weapon
        SET index = 4
      END
    END
  END

END

// this function moves an item in a creture file into a slot where it can't be pickocketed
// also used to move items out of helmet slot for non-legit crit protection
DEFINE_PATCH_FUNCTION cd_no_pickpocket

  // defines what we're going to check
  STR_VAR item = ""

BEGIN

  READ_LONG 0x2b8 slot_off ELSE 0
  READ_LONG 0x2bc itm_off  ELSE 0
  READ_LONG 0x2c0 itm_num  ELSE 0
  SET added = 0
  FOR (index = 0 ; index < itm_num ; ++index) BEGIN
    READ_ASCII (itm_off + (0x14 * index)) file_item
    PATCH_IF ("%item%" STRING_COMPARE_CASE "%file_item%" = 0) BEGIN
      FOR (index2 = 0 ; index2 < 36 ; ++index2) BEGIN // search through item slots; first pass finds and/or removes
        READ_SHORT (slot_off + (0x02 * index2)) ref
        PATCH_IF (ref = index) BEGIN // if item in question
          PATCH_IF ((index2 = 1) OR (index2 = 3) OR ((index2 > 6) AND (index2 < 18))) BEGIN // if legit slot (1, 3, 7-17)
            SET added = 1
          END ELSE BEGIN
            WRITE_SHORT (slot_off + (0x02 * index2)) 0xffff // nulls reference
          END
        END
      END
      PATCH_IF added = 0 BEGIN // if not in a legit slot to begin with
        FOR (index2 = 1 ; index2 < 36 ; ++index2) BEGIN // search through item slots (skipping helmet at 0); first pass finds and/or removes
          PATCH_IF (index2 =  2) BEGIN SET index2 =  3 END // skip shield slot
          PATCH_IF (index2 =  4) BEGIN SET index2 =  7 END // skip rings & amulet
          PATCH_IF (index2 = 18) BEGIN SET index2 = 21 END // skip quick slots
          READ_SHORT (slot_off + (0x02 * index2)) ref
          PATCH_IF (ref = 0xffff) BEGIN // if empty, legit slot
            WRITE_SHORT (slot_off + (0x02 * index2)) index // adds reference
            SET index  = itm_num  // kill loops
            SET index2 = 36       // kill loops
          END
        END
      END
    END
  END

END

// found by Ardanis in Rogue Rebalancing, had apparently been written by Nythrun
// fixed two things, wrapped a function over it

DEFINE_PATCH_FUNCTION ~FJ_SPL_ITM_REINDEX~ BEGIN

  PATCH_IF !(~%SOURCE_FILE%~ STRING_MATCHES_REGEXP ~^.+\.spl~) BEGIN
    hs = 0x28
    WRITE_LONG 0xc ~-1~ //Identified name
    WRITE_LONG 0x54 ~-1~ //Identified description
    PATCH_FOR_EACH tz IN 0x44 0x48 0x58 0x5c BEGIN
      WRITE_LONG tz 0
    END
  END ELSE PATCH_IF !(~%SOURCE_FILE%~ STRING_MATCHES_REGEXP ~^.+\.itm~) BEGIN
    hs = 0x38
  END
  READ_LONG 0x64 hf //Extended header offset
  READ_SHORT 0x68 hc //Extended header count
  READ_LONG 0x6a fb //Feature block table offset
  READ_SHORT 0x70 fc //Feature block count
  PATCH_IF ((hf > fb) AND (hc > 0)) BEGIN // Ardanis: fixed "hc > 1" to "hc > 0"
    READ_ASCII hf ~eh~ ELSE ~fail~ (hs * hc)
    PATCH_IF (~%eh%~ STRING_EQUAL ~fail~) BEGIN
      WHILE ((~%eh%~ STRING_EQUAL ~fail~) AND (hc > 0)) BEGIN
        READ_ASCII hf ~eh~ ELSE ~fail~ (hs * hc)
        hc -= 1
      END
    END
    DELETE_BYTES hf (hs * hc)
    hf = 0x72
    WRITE_LONG 0x64 hf
    WRITE_SHORT 0x68 hc
    fb = (0x72 + (hs * hc))
    WRITE_LONG 0x6a fb
    PATCH_IF !(~%eh%~ STRING_EQUAL ~fail~) BEGIN
      INSERT_BYTES hf (hs * hc)
      WRITE_ASCIIE hf ~%eh%~
    END
  END ELSE PATCH_IF ((hf != 0x72) AND (hc = 0)) BEGIN
    hf = 0x72
    WRITE_LONG 0x64 hf
  END
  FOR (i1 = 0; i1 < (hs * hc); i1 += hs) BEGIN
    WRITE_SHORT (hf + i1 + 0x20) fc
    READ_SHORT (hf + i1 + 0x1e) cx
    fc += cx
  END
  PATCH_IF (SOURCE_SIZE > (0x72 + (hs * hc) + (0x30 * fc))) BEGIN
    DELETE_BYTES (0x72 + (hs * hc) + (0x30 * fc)) (SOURCE_SIZE - (0x72 + (hs * hc) + (0x30 * fc)))
  END

  // added by Ardanis
  WRITE_SHORT 0x6e 0

END // end of function

/////                                                  \\\\\
///// CD_EXTEND-O-MATIC, patent pending                \\\\\
/////                                                  \\\\\

// this function creates headers and does basic duration extensions to level 30; written for inwd-in-bg2 ages ago
DEFINE_PATCH_FUNCTION CD_EXTEND-O-MATIC
  INT_VAR base_dur    =  0 // constant to add to all durations
          step_dur    =  6 // how much duration to add to each consecutive header
          step_size   =  1 // how many levels between headers
          level_cap   = 20 // stop extending at level
          min_dur     =  4 // ignore effects with durations less than this (e.g. cosmetics)
          dur_special =  0 // just add step_dur to existing effects (ignore base_dur)
          min_lev_alt =  0 // if extending from level 1, use this value as its minimum level instead (e.g. fifth level spell with only one header, use 9 here)
BEGIN

  READ_LONG  0x64 abil_off
  READ_SHORT 0x68 abil_num
  READ_LONG  0x6a fx_off
  READ_SHORT (abil_off + 0x10 + (0x28 * (abil_num - 1))) min_lev // read level of last ability
  PATCH_IF ((min_lev = 1) AND (min_lev_alt != 0)) BEGIN SET min_lev = min_lev_alt END
  FOR (index = min_lev + step_size ; index < (level_cap + 1) ; index = index + step_size) BEGIN
    READ_ASCII (abil_off +        (0x28 * (abil_num - 1))) abil (0x28) // read entire ability
    READ_SHORT (abil_off + 0x1e + (0x28 * (abil_num - 1))) abil_fx_num
    READ_SHORT (abil_off + 0x20 + (0x28 * (abil_num - 1))) abil_fx_idx
    READ_ASCII (fx_off +        (0x30 * abil_fx_idx)) effects (abil_fx_num * 0x30) // read entire fx block
    INSERT_BYTES (fx_off +        (0x30 * (abil_fx_idx + abil_fx_num))) (abil_fx_num * 0x30) // insert bytes for new ability
    WRITE_ASCIIE (fx_off +        (0x30 * (abil_fx_idx + abil_fx_num))) "%effects%"          // write in effects block
    FOR (index2 = 0 ; index2 < abil_fx_num ; ++index2) BEGIN
      READ_LONG (fx_off + 0x0e + (0x30 * (abil_fx_idx + abil_fx_num + index2))) duration
      PATCH_IF (duration > min_dur) BEGIN // exclude instant/cosmetic efects
        PATCH_IF dur_special = 1 BEGIN
          SET new_dur = duration + step_dur
        END ELSE BEGIN
          SET new_dur = (base_dur + (index * step_dur))
        END
        WRITE_LONG (fx_off + 0x0e + (0x30 * (abil_fx_idx + abil_fx_num + index2))) new_dur // adjust durations
      END
    END
    INSERT_BYTES (abil_off +        (0x28 * abil_num)) 0x28 // insert new ability
    WRITE_ASCIIE (abil_off +        (0x28 * abil_num)) "%abil%"
    WRITE_SHORT  (abil_off + 0x10 + (0x28 * abil_num)) index
    WRITE_SHORT  (abil_off + 0x20 + (0x28 * abil_num)) (abil_fx_idx + abil_fx_num)
    SET abil_num += 1
    SET fx_off   += 0x28
  END
  WRITE_SHORT 0x68 abil_num
  WRITE_LONG  0x6a fx_off

END

/////                                                  \\\\\
///// cd_make_subspell                                 \\\\\
/////                                                  \\\\\

DEFINE_PATCH_MACRO ~cd_make_subspell~ BEGIN
  WRITE_LONG 0x08 "-1" // blank name
  WRITE_LONG 0x50 "-1" // blank desc
  WRITE_ASCII 0x22 ~~ #6 // blank casting anim, school, secondary
  LPF ALTER_HEADER INT_VAR projectile = 1 END
  LPF ALTER_EFFECT INT_VAR power = 0 resist_dispel = 0 savingthrow = 0 END
END

/////                                                  \\\\\
///// cd_move_actor action/patch function              \\\\\
/////                                                  \\\\\

DEFINE_ACTION_FUNCTION cd_move_actor

  INT_VAR old_x = "-1" // old coordinates for matching
          old_y = "-1"
          new_x = "-1" // new coordinates
          new_y = "-1"
  STR_VAR area  = "none" // area to patch w/o .are extension

BEGIN

  COPY_EXISTING ~%area%.are~ ~override~
    LPF cd_move_actor INT_VAR old_x old_y new_x new_y END
    BUT_ONLY IF_EXISTS // formally, should ACTION_IF with a WARNING if %area%.are not found... but meh

END

DEFINE_PATCH_FUNCTION cd_move_actor

  INT_VAR old_x = "-1" // old coordinates for matching
          old_y = "-1"
          new_x = "-1" // new coordinates
          new_y = "-1"
BEGIN

  READ_LONG  0x54 actor_off
  READ_SHORT 0x58 actor_num
  FOR (index = 0 ; index < actor_num ; ++index) BEGIN
    READ_SHORT (actor_off + 0x20 + (index * 0x110)) test_x
    READ_SHORT (actor_off + 0x22 + (index * 0x110)) test_y
    PATCH_IF ((test_x = old_x) AND (test_y = old_y)) BEGIN
      WRITE_SHORT (actor_off + 0x20 + (index * 0x110)) new_x // location
      WRITE_SHORT (actor_off + 0x22 + (index * 0x110)) new_y
      WRITE_SHORT (actor_off + 0x24 + (index * 0x110)) new_x // destination
      WRITE_SHORT (actor_off + 0x26 + (index * 0x110)) new_y
    END
  END

END

/////                                                  \\\\\
///// cd_define_area_vertices                          \\\\\
/////                                                  \\\\\

/*
angel found a number of opened doors with broken/missing vertices, and fixes
them in his MiH Fixes & Restorations. Unfortunately, they were fixed with SFO
so they needed to be converted to bogstandard functions. This function allow
you to alter the vertices of any area structure--containers, regions, or the
four sets of vertices used by doors--by deleting the existing vertices and
using an external cd_define_area_vertices_array for the new vertices. This
array *must* be defined prior to the function launch.

The bounding box and launch points are optional to specify, though the
bounding box values are ignored for impeded door vertices since they don't
have a bounding box.
*/

DEFINE_PATCH_FUNCTION cd_define_area_vertices
  INT_VAR bounding_left   = "-1" // optional
          bounding_top    = "-1" // optional
          bounding_right  = "-1" // optional
          bounding_bottom = "-1" // optional
          launch_point_x  = "-1" // optional
          launch_point_y  = "-1" // optional
  STR_VAR struct_name  = ~~ // required: name of the door/region/container to be patched
          struct_type  = ~~ // required with allowed values: container, region, door_open, door_closed, door_impeded_open, door_impeded_closed
BEGIN

  SET door_internal = "-1"
  PATCH_IF ("%struct_type%" STRING_COMPARE_REGEXP "door_\(open\|closed\|impeded_open\|impeded_closed\)" = 0) BEGIN // any door
    READ_LONG  0xa4 struct_num
    READ_LONG  0xa8 struct_off
    SET struct_length = 0xc8
    SET local_launch_off = 0x74
    PATCH_IF ("%struct_type%" STRING_COMPARE_CASE "door_open" = 0) BEGIN // open door
      SET local_bound_off = 0x38
      SET local_vert_idx_off = 0x2c
      SET local_vert_num_off = 0x30
      SET door_internal = 4
    END ELSE
    PATCH_IF ("%struct_type%" STRING_COMPARE_CASE "door_closed" = 0) BEGIN // closed door
      SET local_bound_off = 0x40
      SET local_vert_idx_off = 0x34
      SET local_vert_num_off = 0x32
      SET door_internal = 3
    END ELSE
    PATCH_IF ("%struct_type%" STRING_COMPARE_CASE "door_impeded_open" = 0) BEGIN // open, impeded door
      SET local_bound_off = 0
      SET local_vert_idx_off = 0x48
      SET local_vert_num_off = 0x4c
      SET door_internal = 2
    END ELSE BEGIN // closed, impeded door
      SET local_bound_off = 0
      SET local_vert_idx_off = 0x50
      SET local_vert_num_off = 0x4e
      SET door_internal = 1
    END
  END ELSE
  PATCH_IF ("%struct_type%" STRING_COMPARE_CASE "container" = 0) BEGIN // container
    SET local_bound_off = 0x38
    SET local_vert_idx_off = 0x54
    SET local_vert_num_off = 0x50
    SET local_launch_off = 0x34
    READ_SHORT 0x74 struct_num
    READ_LONG  0x70 struct_off
    SET struct_length = 0xc0
    SET door_internal = 0
  END ELSE
  PATCH_IF ("%struct_type%" STRING_COMPARE_CASE "region" = 0) BEGIN // region/trigger
    SET local_bound_off = 0x22
    SET local_vert_idx_off = 0x2c
    SET local_vert_num_off = 0x2a
    SET local_launch_off = 0x70
    READ_SHORT 0x5a struct_num
    READ_LONG  0x5c struct_off
    SET struct_length = 0xc4
    SET door_internal = 0
  END
  PATCH_IF door_internal < 0 BEGIN
    PATCH_PRINT ~ == No changes made with cd_define_area_vertices: Unknown structure type specified (%struct_type%)~
  END ELSE BEGIN
    SET vert_delta = 0
    READ_LONG  0x7c vert_off
    READ_SHORT 0x80 vert_num
    FOR (index = 0 ; index < struct_num ; ++index) BEGIN
      READ_ASCII (struct_off + 0x00 + (index * struct_length)) name_check
      PATCH_IF ("%name_check%" STRING_COMPARE_CASE "%struct_name%") BEGIN // NOT the matched door/region/container
        PATCH_IF vert_delta != 0 BEGIN // don't bother if number of vertices hasn't changed (yet)
          PATCH_IF door_internal = 0 BEGIN // update container/region
            WRITE_LONG (struct_off + local_vert_idx_off + (index * struct_length)) THIS + vert_delta // update vertex index
          END ELSE BEGIN // update four door indices
            WRITE_LONG (struct_off + 0x2c + (index * struct_length)) THIS + vert_delta // open door vertex index
            WRITE_LONG (struct_off + 0x34 + (index * struct_length)) THIS + vert_delta // closed door vertex index
            WRITE_LONG (struct_off + 0x48 + (index * struct_length)) THIS + vert_delta // impeded-open door vertex index
            WRITE_LONG (struct_off + 0x50 + (index * struct_length)) THIS + vert_delta // impeded-closed door vertex index
          END
        END
      END ELSE BEGIN // matched door/region/container
        PATCH_IF local_bound_off != 0 BEGIN // skip for impeded doors
          PATCH_IF bounding_left >= 0 BEGIN // only if set
            WRITE_SHORT (struct_off + local_bound_off + 0x00 + (index * struct_length)) bounding_left   // set the new bounding box
          END
          PATCH_IF bounding_top >= 0 BEGIN // only if set
            WRITE_SHORT (struct_off + local_bound_off + 0x02 + (index * struct_length)) bounding_top    // set the new bounding box
          END
          PATCH_IF bounding_right >= 0 BEGIN // only if set
            WRITE_SHORT (struct_off + local_bound_off + 0x04 + (index * struct_length)) bounding_right  // set the new bounding box
          END
          PATCH_IF bounding_bottom >= 0 BEGIN // only if set
            WRITE_SHORT (struct_off + local_bound_off + 0x06 + (index * struct_length)) bounding_bottom // set the new bounding box
          END
        END
        PATCH_IF launch_point_x >= 0 BEGIN // only if set
          WRITE_SHORT (struct_off + local_launch_off + 0x00 + (index * struct_length)) launch_point_x    // set the new x launch coordinates
        END
        PATCH_IF launch_point_y >= 0 BEGIN // only if set
          WRITE_SHORT (struct_off + local_launch_off + 0x02 + (index * struct_length)) launch_point_y    // set the new y launch coordinates
        END
        READ_LONG   (struct_off + local_vert_idx_off + (index * struct_length)) struct_vert_idx
        READ_SHORT  (struct_off + local_vert_num_off + (index * struct_length)) struct_vert_num
        PATCH_IF struct_vert_num != 0 BEGIN // delete old vertices first
          DELETE_BYTES (vert_off + (0x04 * struct_vert_idx)) (struct_vert_num * 0x04)
          SET vert_delta -= struct_vert_num
          SET struct_vert_num = 0
        END
        PATCH_PHP_EACH cd_define_area_vertices_array AS coords => foo BEGIN
          INSERT_BYTES (vert_off + 0x00 + (0x04 * (struct_vert_num + struct_vert_idx))) 0x04
          WRITE_SHORT  (vert_off + 0x00 + (0x04 * (struct_vert_num + struct_vert_idx))) coords_0
          WRITE_SHORT  (vert_off + 0x02 + (0x04 * (struct_vert_num + struct_vert_idx))) coords_1
          SET struct_vert_num += 1
          SET vert_delta += 1
        END
        WRITE_SHORT  (struct_off + local_vert_num_off + (index * struct_length)) struct_vert_num
        // since doors have four vertex indices, may need additional vertex index updates for anything other than the last one (impeded-closed)
        PATCH_IF door_internal > 1 BEGIN      // impeded-open, closed, or open
          WRITE_LONG (struct_off + 0x50 + (index * struct_length)) THIS + vert_delta     // impeded-closed index
          PATCH_IF door_internal > 2  BEGIN   // closed or open
            WRITE_LONG (struct_off + 0x48 + (index * struct_length)) THIS + vert_delta   // impeded-open index
            PATCH_IF door_internal > 3  BEGIN // open
              WRITE_LONG (struct_off + 0x34 + (index * struct_length)) THIS + vert_delta // closed index
            END
          END
        END // bonus door check
      END // match name check
    END // end structure loop

    // now, to check everything else that uses vertices and update their indices if are listed after the new insertions/deletions
    PATCH_IF vert_delta != 0 BEGIN // don't bother if same number of vertices
      PATCH_FOR_EACH offset IN 0x54 0x5c 0x60 0x68 0x70 0x78 /* 0x7c */ 0x84 0x88 0x90 0xa0 0xa8 0xb0 0xb8 0xbc 0xc0 0xc4 0xcc BEGIN
        READ_LONG offset off_check
        PATCH_IF off_check > vert_off BEGIN // if section is after vertices, adjust accordingly
          WRITE_LONG offset (THIS + (0x04 * vert_delta))
        END
      END
      PATCH_IF ("%struct_type%" STRING_COMPARE_CASE "region") BEGIN // update region indices for containers/door patches
        READ_SHORT 0x5a region_num
        READ_LONG  0x5c region_off
        FOR (index = 0 ; index < region_num ; ++index) BEGIN
          READ_LONG (region_off + 0x2c + (index * 0xc4)) vert_idx
          PATCH_IF vert_idx > struct_vert_idx BEGIN
            WRITE_LONG (region_off + 0x2c + (index * 0xc4)) vert_idx + vert_delta
          END
        END
      END
      PATCH_IF ("%struct_type%" STRING_COMPARE_CASE "container") BEGIN // update container indices for region/door patches
        READ_SHORT 0x74 cont_num
        READ_LONG  0x70 cont_off
        FOR (index = 0 ; index < cont_num ; ++index) BEGIN
          READ_LONG (cont_off + 0x50 + (index * 0xc0)) vert_idx
          PATCH_IF vert_idx > struct_vert_idx BEGIN
            WRITE_LONG (cont_off + 0x50 + (index * 0xc0)) vert_idx + vert_delta
          END
        END
      END
      PATCH_IF !door_internal BEGIN // update door indices for container/region patches
        READ_LONG 0xa4 door_num
        READ_LONG 0xa8 door_off
        FOR (index = 0 ; index < door_num ; ++index) BEGIN
          PATCH_FOR_EACH local_off IN 0x2c 0x34 0x48 0x50 BEGIN // checks open door index, closed door index, impeded-open index, impeded-closed index
            READ_LONG (door_off + local_off + (index * 0xc8)) vert_idx
            PATCH_IF vert_idx > struct_vert_idx BEGIN
              WRITE_LONG (door_off + local_off + (index * 0xc8)) vert_idx + vert_delta
            END
          END
        END
      END
      WRITE_SHORT 0x80 vert_num + vert_delta
    END // vert_delta check

  END // end valid structure check

END
