/////                                                  \\\\\
///// cd_string_set_from_tra                           \\\\\
/////                                                  \\\\\

// this function process a tra file into string_sets based on the tra reference, e.g. @123 is used as STRING_SET 123 @123
// this function creates headers and does basic duration extensions to level 30; written for inwd-in-bg2 ages ago
DEFINE_ACTION_FUNCTION cd_string_set_from_tra
  INT_VAR cd_mode    = 1  // set to 0 will generate tph files; 1 will build and execute them
  STR_VAR input_tra  = ~~ // tra file to process
          output_tph = ~~ // tph being built; use weidu_external for this
BEGIN

  ACTION_IF FILE_EXISTS ~%input_tra%~ BEGIN // skip sod for non-bgee

<<<<<<<<./inlined/blank.txt
>>>>>>>>
    COPY ~./inlined/blank.txt~ ~%output_tph%~

    ACTION_IF !cd_mode BEGIN

      APPEND_OUTER ~%output_tph%~ "// this file is automatically generated by SECRET COMPONENT 999 from %input_tra% - there is no need to manually update it"

    END

    APPEND_OUTER ~%output_tph%~ "WITH_TRA ~%input_tra%~ BEGIN STRING_SET"

    COPY ~%input_tra%~ ~%input_tra%~
      REPLACE_EVALUATE ~^\([ %TAB%]*@\)\([0-9]+\)\([ %TAB%]*=\)~ BEGIN
        INNER_ACTION BEGIN
          APPEND_OUTER ~%output_tph%~ ~  %MATCH2% @%MATCH2%~
        END
      END ~%MATCH1%%MATCH2%%MATCH3%~
      BUT_ONLY

    APPEND_OUTER ~%output_tph%~ ~END~

    ACTION_IF cd_mode BEGIN

      INCLUDE ~%output_tph%~

    END

  END

END

/////                                                  \\\\\
///// alter_header                                     \\\\\
/////                                                  \\\\\

// got tired of crappy ALTER_ITEM_HEADER and ALTER_SPELL_HEADER
DEFINE_PATCH_FUNCTION ALTER_HEADER

  // defines what we're going to check
  INT_VAR multi_match         = 999
          verbose             = 0
          silent              = 0
          header              = "-1"

  // variables for finding the effect to match
          match_type        = "-1"
          match_location    = "-1"
          match_target      = "-1"
          match_target_num  = "-1"
          match_range       = "-1"
          match_speed       = "-1"
          match_projectile  = "-1"
          // spell headers only
          match_level       = "-1"
          // item headers only
          match_identify       = "-1"
          match_alt_dicesize   = "-1"
          match_launcher       = "-1"
          match_alt_dicenumber = "-1"
          match_alt_damage     = "-1"
          match_to_hit         = "-1"
          match_dicesize       = "-1"
          match_primary        = "-1"
          match_dicenumber     = "-1"
          match_secondary      = "-1"
          match_damage         = "-1"
          match_damage_type    = "-1"
          match_charges        = "-1"
          match_drained        = "-1"
          match_overhand       = "-1"
          match_backhand       = "-1"
          match_thrust         = "-1"
          match_arrow          = "-1"
          match_bolt           = "-1"
          match_bullet         = "-1"
          // flags at 0x26 (still item only)
          match_flag_strength      = "-1" // add strength bonus, bit0
          match_flag_break         = "-1" // breakable, bit1
          match_flag_str_damage    = "-1" // strength damage bonus, ee, bit2
          match_flag_str_to_hit    = "-1" // strength thac0 bonus, ee, bit3
          match_flag_hostile       = "-1" // hostile, bit10
          match_flag_recharge      = "-1" // recharge after resting, bit11
          match_flag_bypass        = "-1" // bypass armor, bit16
          match_flag_keenedge      = "-1" // keen edge, bit17
          match_flag_backstab      = "-1" // tobex only, toggle backstab, bit25
          match_flag_noinvisible   = "-1" // tobex only, cannot target invisible, bit26

  // variables for the new effect
          type        = "-1"
          location    = "-1"
          target      = "-1"
          target_num  = "-1"
          range       = "-1"
          speed       = "-1"
          projectile  = "-1"
          // spell headers only
          level       = "-1"
          // item headers only
          identify       = "-1"
          alt_dicesize   = "-1"
          launcher       = "-1"
          alt_dicenumber = "-1"
          alt_damage     = "-1"
          to_hit         = "-1"
          dicesize       = "-1"
          primary        = "-1"
          dicenumber     = "-1"
          secondary      = "-1"
          damage         = "-1"
          damage_type    = "-1"
          charges        = "-1"
          drained        = "-1"
          overhand       = "-1"
          backhand       = "-1"
          thrust         = "-1"
          arrow          = "-1"
          bolt           = "-1"
          bullet         = "-1"
          // flags at 0x26
          flag_strength      = "-1" // add strength bonus, bit0
          flag_break         = "-1" // breakable, bit1
          flag_str_damage    = "-1" // strength damage bonus, ee, bit2
          flag_str_to_hit    = "-1" // strength thac0 bonus, ee, bit3
          flag_hostile       = "-1" // hostile, bit10
          flag_recharge      = "-1" // recharge after resting, bit11
          flag_bypass        = "-1" // bypass armor, bit16
          flag_keenedge      = "-1" // keen edge, bit17
          flag_backstab      = "-1" // tobex only, toggle backstab, bit25
          flag_noinvisible   = "-1" // tobex only, cannot target invisible, bit26

  // same for match and new STR_VAR
  STR_VAR match_icon      = "SAME"
          icon            = "SAME"
BEGIN

  READ_ASCII 0x00 sig (3)
  SET abil_length = 0
  SET proceed = 0
  SET alter = 0
  PATCH_IF ("%sig%" STRING_COMPARE_CASE "ITM" = 0) BEGIN
    SET abil_length = 0x38
  END ELSE
  PATCH_IF ("%sig%" STRING_COMPARE_CASE "SPL" = 0) BEGIN
    SET abil_length = 0x28
  END
  PATCH_IF abil_length = 0 BEGIN
    PATCH_WARN ~WARNING: file type not recognized on %SOURCE_FILE% for ALTER_HEADER macro.~
  END ELSE BEGIN
    SET pro_off = abil_length = 0x38 ? 0x2a : 0x26
    READ_LONG   0x64 abil_off
    READ_SHORT  0x68 abil_num
    FOR (index = 0 ; index < abil_num ; ++index) BEGIN
      PATCH_IF ((header < 0) OR (header = index)) BEGIN
        SET base = abil_off + (index * abil_length)
        READ_BYTE  (base + 0x00) o_type
        READ_BYTE  (base + 0x02) o_location
        READ_ASCII (base + 0x04) o_icon (8) NULL
        READ_BYTE  (base + 0x0c) o_target
        READ_BYTE  (base + 0x0d) o_target_num
        READ_SHORT (base + 0x0e) o_range
        READ_SHORT (base + pro_off) o_projectile
        PATCH_IF abil_length = 0x38 BEGIN
          // item headers only
          READ_BYTE  (base + 0x01) o_identify
          READ_BYTE  (base + 0x03) o_alt_dicesize
          READ_BYTE  (base + 0x10) o_launcher
          READ_BYTE  (base + 0x11) o_alt_dicenumber
          READ_BYTE  (base + 0x12) o_speed
          READ_BYTE  (base + 0x13) o_alt_damage
          READ_SHORT (base + 0x14) o_to_hit
          READ_BYTE  (base + 0x16) o_dicesize
          READ_BYTE  (base + 0x17) o_primary
          READ_BYTE  (base + 0x18) o_dicenumber
          READ_BYTE  (base + 0x19) o_secondary
          READ_SHORT (base + 0x1a) o_damage
          READ_SHORT (base + 0x1c) o_damage_type
          READ_SHORT (base + 0x22) o_charges
          READ_SHORT (base + 0x24) o_drained
          READ_LONG  (base + 0x26) o_flags
          READ_SHORT (base + 0x2c) o_overhand
          READ_SHORT (base + 0x2e) o_backhand
          READ_SHORT (base + 0x30) o_thrust
          READ_SHORT (base + 0x32) o_arrow
          READ_SHORT (base + 0x34) o_bolt
          READ_SHORT (base + 0x36) o_bullet
        END ELSE BEGIN
          READ_SHORT (base + 0x10) o_level
          READ_SHORT (base + 0x12) o_speed
        END
        // now check our header vs. the match variables
        PATCH_IF ((multi_match != 0) AND
                  ((match_type       = o_type)       OR (match_type < 0))       AND
                  ((match_type       = o_type)       OR (match_type < 0))       AND
                  ((match_location   = o_location)   OR (match_location < 0))   AND
                  ((match_target     = o_target)     OR (match_target < 0))     AND
                  ((match_target_num = o_target_num) OR (match_target_num < 0)) AND
                  ((match_range      = o_range)      OR (match_range < 0))      AND
                  ((match_speed      = o_speed)      OR (match_speed < 0))      AND
                  ((match_projectile = o_projectile) OR (match_projectile < 0)) AND
                  (("%match_icon%" STRING_COMPARE_CASE "%o_icon%" = 0) OR ("%match_icon%" STRING_COMPARE_CASE "SAME" = 0))) BEGIN
          PATCH_IF (abil_length = 0x38) BEGIN  // item-specific checks
            PATCH_IF (((match_identify       = o_identify)       OR (match_identify < 0))       AND
                      ((match_alt_dicesize   = o_alt_dicesize)   OR (match_alt_dicesize < 0))   AND
                      ((match_launcher       = o_launcher)       OR (match_launcher < 0))       AND
                      ((match_alt_dicenumber = o_alt_dicenumber) OR (match_alt_dicenumber < 0)) AND
                      ((match_alt_damage     = o_alt_damage)     OR (match_alt_damage < 0))     AND
                      ((match_to_hit         = o_to_hit)         OR (match_to_hit < 0))         AND
                      ((match_dicesize       = o_dicesize)       OR (match_dicesize < 0))       AND
                      ((match_primary        = o_primary)        OR (match_primary < 0))        AND
                      ((match_dicenumber     = o_dicenumber)     OR (match_dicenumber < 0))     AND
                      ((match_secondary      = o_secondary)      OR (match_secondary < 0))      AND
                      ((match_damage         = o_damage)         OR (match_damage < 0))         AND
                      ((match_damage_type    = o_damage_type)    OR (match_damage_type < 0))    AND
                      ((match_charges        = o_charges)        OR (match_charges < 0))        AND
                      ((match_drained        = o_drained)        OR (match_drained < 0))        AND
                      ((match_overhand       = o_overhand)       OR (match_overhand < 0))       AND
                      ((match_backhand       = o_backhand)       OR (match_backhand < 0))       AND
                      ((match_thrust         = o_thrust)         OR (match_thrust < 0))         AND
                      ((match_arrow          = o_arrow)          OR (match_arrow < 0))          AND
                      ((match_bolt           = o_bolt)           OR (match_bolt < 0))           AND
                      ((match_bullet         = o_bullet)         OR (match_bullet < 0))         AND
                      ((match_flag_strength < 0) OR
                       (match_flag_strength = (flags & BIT0)) OR // not set
                       (match_flag_strength > 0 AND (flags & BIT0) = BIT0)) AND
                      ((match_flag_break < 0) OR
                       (match_flag_break = (flags & BIT1)) OR // not set
                       (match_flag_break > 0 AND (flags & BIT1) = BIT1)) AND
                      ((match_flag_str_damage < 0) OR
                       (match_flag_str_damage = (flags & BIT2)) OR // not set
                       (match_flag_str_damage > 0 AND (flags & BIT2) = BIT2)) AND
                      ((match_flag_str_to_hit < 0) OR
                       (match_flag_str_to_hit = (flags & BIT3)) OR // not set
                       (match_flag_str_to_hit > 0 AND (flags & BIT3) = BIT3)) AND
                      ((match_flag_hostile < 0) OR
                       (match_flag_hostile = (flags & BIT10)) OR // not set
                       (match_flag_hostile > 0 AND (flags & BIT10) = BIT10)) AND
                      ((match_flag_recharge < 0) OR
                       (match_flag_recharge = (flags & BIT11)) OR // not set
                       (match_flag_recharge > 0 AND (flags & BIT11) = BIT11)) AND
                      ((match_flag_bypass < 0) OR
                       (match_flag_bypass = (flags & BIT16)) OR // not set
                       (match_flag_bypass > 0 AND (flags & BIT16) = BIT16)) AND
                      ((match_flag_keenedge < 0) OR
                       (match_flag_keenedge = (flags & BIT17)) OR // not set
                       (match_flag_keenedge > 0 AND (flags & BIT17) = BIT17)) AND
                      ((match_flag_backstab < 0) OR
                       (match_flag_backstab = (flags & BIT25)) OR // not set
                       (match_flag_backstab > 0 AND (flags & BIT25) = BIT25)) AND
                      ((match_flag_noinvisible < 0) OR
                       (match_flag_noinvisible = (flags & BIT26)) OR // not set
                       (match_flag_noinvisible > 0 AND (flags & BIT26) = BIT26))) BEGIN
              SET proceed = 1
            END
          END ELSE BEGIN // spell-specific checks
            PATCH_IF ((match_level = o_level) OR (match_level < 0)) BEGIN
              SET proceed = 1
            END
          END
          PATCH_IF proceed BEGIN
            SET alter += 1
            SET multi_match -= 1
            PATCH_IF (type >= 0)       BEGIN WRITE_BYTE  (base + 0x00) type END
            PATCH_IF (location >= 0)   BEGIN WRITE_BYTE  (base + 0x02) location END
            PATCH_IF (target >= 0)     BEGIN WRITE_BYTE  (base + 0x0c) target END
            PATCH_IF (target_num >= 0) BEGIN WRITE_BYTE  (base + 0x0d) target_num END
            PATCH_IF (range >= 0)      BEGIN WRITE_SHORT (base + 0x0e) range END
            PATCH_IF (projectile >= 0) BEGIN WRITE_SHORT (base + pro_off) projectile END
            PATCH_IF ("%icon%" STRING_COMPARE_CASE "SAME") BEGIN WRITE_ASCIIE (base + 0x04) ~%icon%~ #8 END
            PATCH_IF abil_length = 0x38 BEGIN // item headers
              PATCH_IF (identify >= 0)       BEGIN WRITE_BYTE  (base + 0x01) identify       END
              PATCH_IF (alt_dicesize >= 0)   BEGIN WRITE_BYTE  (base + 0x03) alt_dicesize   END
              PATCH_IF (launcher >= 0)       BEGIN WRITE_BYTE  (base + 0x10) launcher       END
              PATCH_IF (alt_dicenumber >= 0) BEGIN WRITE_BYTE  (base + 0x11) alt_dicenumber END
              PATCH_IF (speed >= 0)          BEGIN WRITE_BYTE  (base + 0x12) speed          END
              PATCH_IF (alt_damage >= 0)     BEGIN WRITE_BYTE  (base + 0x13) alt_damage     END
              PATCH_IF (to_hit >= 0)         BEGIN WRITE_SHORT (base + 0x14) to_hit         END
              PATCH_IF (dicesize >= 0)       BEGIN WRITE_BYTE  (base + 0x16) dicesize       END
              PATCH_IF (primary >= 0)        BEGIN WRITE_BYTE  (base + 0x17) primary        END
              PATCH_IF (dicenumber >= 0)     BEGIN WRITE_BYTE  (base + 0x18) dicenumber     END
              PATCH_IF (secondary >= 0)      BEGIN WRITE_BYTE  (base + 0x19) secondary      END
              PATCH_IF (damage >= 0)         BEGIN WRITE_SHORT (base + 0x1a) damage         END
              PATCH_IF (damage_type >= 0)    BEGIN WRITE_SHORT (base + 0x1c) damage_type    END
              PATCH_IF (charges >= 0)        BEGIN WRITE_SHORT (base + 0x22) charges        END
              PATCH_IF (drained >= 0)        BEGIN WRITE_SHORT (base + 0x24) drained        END
              PATCH_IF (overhand >= 0)       BEGIN WRITE_SHORT (base + 0x2c) overhand       END
              PATCH_IF (backhand >= 0)       BEGIN WRITE_SHORT (base + 0x2e) backhand       END
              PATCH_IF (thrust >= 0)         BEGIN WRITE_SHORT (base + 0x30) thrust         END
              PATCH_IF (arrow >= 0)          BEGIN WRITE_SHORT (base + 0x32) arrow          END
              PATCH_IF (bolt >= 0)           BEGIN WRITE_SHORT (base + 0x34) bolt           END
              PATCH_IF (bullet >= 0)         BEGIN WRITE_SHORT (base + 0x36) bullet         END

              PATCH_IF (flag_strength = 0)    BEGIN WRITE_LONG (base + 0x26) (THIS &  `BIT0)  END
              PATCH_IF (flag_strength > 0)    BEGIN WRITE_LONG (base + 0x26) (THIS BOR BIT0)  END
              PATCH_IF (flag_break = 0)       BEGIN WRITE_LONG (base + 0x26) (THIS &  `BIT1)  END
              PATCH_IF (flag_break > 0)       BEGIN WRITE_LONG (base + 0x26) (THIS BOR BIT1)  END
              PATCH_IF (flag_str_damage = 0)  BEGIN WRITE_LONG (base + 0x26) (THIS &  `BIT2)  END
              PATCH_IF (flag_str_damage > 0)  BEGIN WRITE_LONG (base + 0x26) (THIS BOR BIT2)  END
              PATCH_IF (flag_str_to_hit = 0)  BEGIN WRITE_LONG (base + 0x26) (THIS &  `BIT3)  END
              PATCH_IF (flag_str_to_hit > 0)  BEGIN WRITE_LONG (base + 0x26) (THIS BOR BIT3)  END
              PATCH_IF (flag_hostile = 0)     BEGIN WRITE_LONG (base + 0x26) (THIS &  `BIT10) END
              PATCH_IF (flag_hostile > 0)     BEGIN WRITE_LONG (base + 0x26) (THIS BOR BIT10) END
              PATCH_IF (flag_recharge = 0)    BEGIN WRITE_LONG (base + 0x26) (THIS &  `BIT11) END
              PATCH_IF (flag_recharge > 0)    BEGIN WRITE_LONG (base + 0x26) (THIS BOR BIT11) END
              PATCH_IF (flag_bypass = 0)      BEGIN WRITE_LONG (base + 0x26) (THIS &  `BIT16) END
              PATCH_IF (flag_bypass > 0)      BEGIN WRITE_LONG (base + 0x26) (THIS BOR BIT16) END
              PATCH_IF (flag_keenedge = 0)    BEGIN WRITE_LONG (base + 0x26) (THIS &  `BIT17) END
              PATCH_IF (flag_keenedge > 0)    BEGIN WRITE_LONG (base + 0x26) (THIS BOR BIT17) END
              PATCH_IF (flag_backstab = 0)    BEGIN WRITE_LONG (base + 0x26) (THIS &  `BIT25) END
              PATCH_IF (flag_backstab > 0)    BEGIN WRITE_LONG (base + 0x26) (THIS BOR BIT25) END
              PATCH_IF (flag_noinvisible = 0) BEGIN WRITE_LONG (base + 0x26) (THIS &  `BIT26) END
              PATCH_IF (flag_noinvisible > 0) BEGIN WRITE_LONG (base + 0x26) (THIS BOR BIT26) END
            END ELSE BEGIN // spell headers
              PATCH_IF (level >= 0) BEGIN WRITE_SHORT (base + 0x10) level END
              PATCH_IF (speed >= 0) BEGIN WRITE_SHORT (base + 0x12) speed END
            END
          END // proceed check
        END // mutual fields check
      END // for loop
    END // header check
  END // abil_length check

  PATCH_IF (alter = 0 && !silent) BEGIN
    PATCH_WARN "WARNING: no effects altered on %SOURCE_FILE% via ALTER_HEADER"
  END

  PATCH_IF (verbose && !silent) BEGIN
    READ_LONG 0x0c strref
    PATCH_IF ((strref > 0) AND (strref < 200000)) BEGIN
      READ_STRREF 0x0c name
    END ELSE BEGIN
      READ_STRREF 0x08 name
    END
    PATCH_PRINT "              ~%SOURCE_FILE%~   ~override~ // %name%, %alter% effect(s) altered"
  END

END

/////                                                  \\\\\
///// ALTER_AREA/CREATURE_ITEM                         \\\\\
/////                                                  \\\\\

// alter_creature and alter_area just feed into a common macro that does the work

DEFINE_PATCH_FUNCTION ALTER_AREA_ITEM

  // defines what we're going to check
  INT_VAR expiry           = "-1"
          charge1          = "-1"
          charge2          = "-1"
          charge3          = "-1"
          flags            = "-1"
          flag_identified  = "-1"
          flag_unstealable = "-1"
          flag_stolen      = "-1"
          flag_undroppable = "-1"
  STR_VAR item       = "same"
          match_item = "same"

BEGIN

  READ_SHORT 0x76 item_num ELSE 0
  READ_LONG  0x78 item_off ELSE 0
  LPF ALTER_AREA-CREATURE_ITEM INT_VAR expiry charge1 charge2 charge3 flags flag_identified flag_unstealable flag_stolen flag_undroppable item_num item_off
                               STR_VAR item match_item END

END

DEFINE_PATCH_FUNCTION ALTER_CREATURE_ITEM

  // defines what we're going to check
  INT_VAR expiry           = "-1"
          charge1          = "-1"
          charge2          = "-1"
          charge3          = "-1"
          flags            = "-1"
          flag_identified  = "-1"
          flag_unstealable = "-1"
          flag_stolen      = "-1"
          flag_undroppable = "-1"
  STR_VAR item       = "same"
          match_item = "same"

BEGIN

  READ_LONG  0x2bc item_off ELSE 0
  READ_LONG  0x2c0 item_num ELSE 0
  LPF ALTER_AREA-CREATURE_ITEM INT_VAR expiry charge1 charge2 charge3 flags flag_identified flag_unstealable flag_stolen flag_undroppable item_num item_off
                               STR_VAR item match_item END

END

DEFINE_PATCH_FUNCTION ALTER_AREA-CREATURE_ITEM

  // defines what we're going to check
  INT_VAR expiry           = "-1"
          charge1          = "-1"
          charge2          = "-1"
          charge3          = "-1"
          flags            = "-1"
          flag_identified  = "-1"
          flag_unstealable = "-1"
          flag_stolen      = "-1"
          flag_undroppable = "-1"
          item_num         = 0
          item_off         = 0
  STR_VAR item       = "same"
          match_item = "same"

BEGIN

  FOR (index = 0 ; index < item_num ; ++index) BEGIN
    SET base = (item_off + (index * 0x14))
    READ_ASCII base o_item
    PATCH_IF (("%o_item%" STRING_COMPARE_CASE "%match_item%" = 0) OR
              ("all"      STRING_COMPARE_CASE "%match_item%" = 0)) BEGIN
      PATCH_IF (expiry >= 0)  BEGIN WRITE_SHORT (base + 0x08) expiry END
      PATCH_IF (charge1 >= 0) BEGIN WRITE_SHORT (base + 0x0a) charge1 END
      PATCH_IF (charge2 >= 0) BEGIN WRITE_SHORT (base + 0x0c) charge2 END
      PATCH_IF (charge3 >= 0) BEGIN WRITE_SHORT (base + 0x0e) charge3 END
      PATCH_IF (flags >= 0)   BEGIN
        WRITE_LONG (base + 0x10) flags
      END ELSE BEGIN // only check individual flags if overall value not given
        PATCH_IF (flag_identified = 0)  BEGIN WRITE_LONG  (base + 0x10) (THIS & `BIT0) END
        PATCH_IF (flag_identified = 1)  BEGIN WRITE_LONG  (base + 0x10) (THIS BOR BIT0) END
        PATCH_IF (flag_unstealable = 0) BEGIN WRITE_LONG  (base + 0x10) (THIS & `BIT1) END
        PATCH_IF (flag_unstealable = 1) BEGIN WRITE_LONG  (base + 0x10) (THIS BOR BIT1) END
        PATCH_IF (flag_stolen = 0)      BEGIN WRITE_LONG  (base + 0x10) (THIS & `BIT2) END
        PATCH_IF (flag_stolen = 1)      BEGIN WRITE_LONG  (base + 0x10) (THIS BOR BIT2) END
        PATCH_IF (flag_undroppable = 0) BEGIN WRITE_LONG  (base + 0x10) (THIS & `BIT3) END
        PATCH_IF (flag_undroppable = 1) BEGIN WRITE_LONG  (base + 0x10) (THIS BOR BIT3) END
      END
      PATCH_IF ("%item%" STRING_COMPARE_CASE "same") BEGIN
        WRITE_ASCIIE base ~%item%~ #8
      END
    END
  END

END

/////                                                  \\\\\
///// miscellaneous creature inventory macros          \\\\\
/////                                                  \\\\\

// this function takes an item listed in a creture file and moves it to an open slot
// it'll try the appropriate slot first and then move to inventory
DEFINE_PATCH_FUNCTION cd_equip_item

  // defines what we're going to check
  INT_VAR move = 0
          gpuse = 0
  STR_VAR item = "same"
          slot = "helmet"

BEGIN

  SET fruitbats = "-1"
  PATCH_IF ("%slot%" STRING_COMPARE_CASE "helmet" = 0) BEGIN
    SET start = 0
  END ELSE
  PATCH_IF ("%slot%" STRING_COMPARE_CASE "armor" = 0) BEGIN
    SET start = 1
  END ELSE
  PATCH_IF ("%slot%" STRING_COMPARE_CASE "shield" = 0) BEGIN
    SET start = 2
  END ELSE
  PATCH_IF ("%slot%" STRING_COMPARE_CASE "gloves" = 0) BEGIN
    SET start = 3
  END ELSE
  PATCH_IF ("%slot%" STRING_COMPARE_CASE "rings" = 0) BEGIN
    SET start = 4
    SET fruitbats = 5
  END ELSE
  PATCH_IF ("%slot%" STRING_COMPARE_CASE "amulet" = 0) BEGIN
    SET start = 6
  END ELSE
  PATCH_IF ("%slot%" STRING_COMPARE_CASE "jewelry" = 0) BEGIN
    SET start = 4
    SET fruitbats = 6
  END ELSE
  PATCH_IF ("%slot%" STRING_COMPARE_CASE "belt" = 0) BEGIN
    SET start = 7
  END ELSE
  PATCH_IF ("%slot%" STRING_COMPARE_CASE "boots" = 0) BEGIN
    SET start = 8
  END ELSE
  PATCH_IF ("%slot%" STRING_COMPARE_CASE "weapon" = 0) BEGIN
    SET start = 9
    SET fruitbats = 12
  END ELSE
  PATCH_IF ("%slot%" STRING_COMPARE_CASE "quiver" = 0) BEGIN
    SET start = 13
    SET fruitbats = 15
  END ELSE
  PATCH_IF ("%slot%" STRING_COMPARE_CASE "quickslot" = 0) BEGIN
    SET start = 18
    SET fruitbats = 20
  END ELSE BEGIN // inventory
    PATCH_IF gpuse = 0 BEGIN // creatures with gpuse scripts will try to use items in the first inventory slots
      SET start = 21
    END ELSE BEGIN
      SET start = 23
    END
    SET fruitbats = 0
  END
  PATCH_IF fruitbats < 0 BEGIN SET fruitbats = start END

  READ_LONG  0x2b8 slot_off ELSE 0
  READ_LONG  0x2bc itm_off ELSE 0
  READ_LONG  0x2c0 itm_num ELSE 0
  FOR (index = 0 ; index < itm_num ; ++index) BEGIN
    READ_ASCII (itm_off + (0x14 * index)) test_item
    PATCH_IF ("%item%" STRING_COMPARE_CASE "%test_item%" = 0) BEGIN
      SET proceed = 1
      FOR (index2 = 0 ; index2 < 36 ; ++index2) BEGIN // first make a loop to make sure it's not assigned somwhere already
        READ_SHORT (slot_off + (index2 * 0x02)) ref
        PATCH_IF ref = index BEGIN
          PATCH_IF move = 1 BEGIN
            WRITE_SHORT (slot_off + (index2 * 0x02)) 0xffff
          END ELSE BEGIN
            SET proceed = 0
          END
        END
      END
      PATCH_IF proceed BEGIN
        FOR (index2 = start ; index2 < 36 ; ++index2) BEGIN // first make a loop to make sure it's not assigned somwhere already
          READ_SHORT (slot_off + (index2 * 0x02)) ref
          PATCH_IF (ref = 0xffff) BEGIN // if null reference in targeted slot
            WRITE_SHORT (slot_off + (index2 * 0x02)) index // adds reference to item
            SET index2 = 36 // kills loop
          END
          PATCH_IF (index2 = fruitbats) BEGIN // if end of possible equipment slots, skip ahead to inventory
            PATCH_IF gpuse = 0 BEGIN // creatures with gpuse scripts will try to use items in the first inventory slots
              SET index2 = 20 // otherwise go to inventory slots
            END ELSE BEGIN
              SET index2 = 22 // otherwise go to inventory slots
            END
          END
        END
      END
    END
  END

END

// run this on creatures with invalid selected weapons; it'll check the weapon slots and update the equipped weapon as needed
DEFINE_PATCH_FUNCTION cd_equip_weapon BEGIN

  READ_LONG  0x2b8 slot_off ELSE 0
  READ_LONG  0x2c0 itm_num  ELSE 0
  WRITE_SHORT (slot_off + 0x4c) 0xffff // null equipped weapon - either patch below will enter a valid value, or no valid value exists
  FOR (index = 0 ; index < 4 ; ++index) BEGIN // search through weapon slots
    READ_SHORT (slot_off + 0x12 + (index * 0x02)) ref
    PATCH_IF ((ref != 0xffff) AND (ref < itm_num)) BEGIN // if valid reference in weapon slots
//    PATCH_IF (ref != 0xffff) BEGIN // if valid reference in weapon slots
      WRITE_SHORT (slot_off + 0x4c) index // equipped weapon
      SET "index" = 4 // kills loop and prevents next patch_if
    END
  END

END

// run this on creatures with invalid selected weapons; it'll check the weapon slots and update the equipped weapon as needed
DEFINE_PATCH_FUNCTION cd_equip_weapon_specific

  // defines what we're going to check
  STR_VAR item = ""

BEGIN


  READ_LONG  0x2b8 slot_off
  READ_LONG  0x2bc itm_off
  FOR (index = 0; index < 4; ++index) BEGIN // cycles through weapon slots
    READ_SHORT (slot_off + 0x12 + (index * 0x02)) slot_num
    PATCH_IF (slot_num < 37) BEGIN
      READ_ASCII (itm_off + (slot_num * 0x14)) weapon
      PATCH_IF ("%item%" STRING_COMPARE_CASE "%weapon%" = 0) BEGIN // if long sword
        WRITE_SHORT (slot_off + 0x4c) index // sets weapon slot to selected weapon
        SET index = 4
      END
    END
  END

END

// this function moves an item in a creture file into a slot where it can't be pickocketed
// also used to move items out of helmet slot for non-legit crit protection
DEFINE_PATCH_FUNCTION cd_no_pickpocket

  // defines what we're going to check
  STR_VAR item = ""

BEGIN

  READ_LONG 0x2b8 slot_off ELSE 0
  READ_LONG 0x2bc itm_off  ELSE 0
  READ_LONG 0x2c0 itm_num  ELSE 0
  SET added = 0
  FOR (index = 0 ; index < itm_num ; ++index) BEGIN
    READ_ASCII (itm_off + (0x14 * index)) file_item
    PATCH_IF ("%item%" STRING_COMPARE_CASE "%file_item%" = 0) BEGIN
      FOR (index2 = 0 ; index2 < 36 ; ++index2) BEGIN // search through item slots; first pass finds and/or removes
        READ_SHORT (slot_off + (0x02 * index2)) ref
        PATCH_IF (ref = index) BEGIN // if item in question
          PATCH_IF ((index2 = 1) OR (index2 = 3) OR ((index2 > 6) AND (index2 < 18))) BEGIN // if legit slot (1, 3, 7-17)
            SET added = 1
          END ELSE BEGIN
            WRITE_SHORT (slot_off + (0x02 * index2)) 0xffff // nulls reference
          END
        END
      END
      PATCH_IF added = 0 BEGIN // if not in a legit slot to begin with
        FOR (index2 = 1 ; index2 < 36 ; ++index2) BEGIN // search through item slots (skipping helmet at 0); first pass finds and/or removes
          PATCH_IF (index2 =  2) BEGIN SET index2 =  3 END // skip shield slot
          PATCH_IF (index2 =  4) BEGIN SET index2 =  7 END // skip rings & amulet
          PATCH_IF (index2 = 18) BEGIN SET index2 = 21 END // skip quick slots
          READ_SHORT (slot_off + (0x02 * index2)) ref
          PATCH_IF (ref = 0xffff) BEGIN // if empty, legit slot
            WRITE_SHORT (slot_off + (0x02 * index2)) index // adds reference
            SET index  = itm_num  // kill loops
            SET index2 = 36       // kill loops
          END
        END
      END
    END
  END

END

// found by Ardanis in Rogue Rebalancing, had apparently been written by Nythrun
// fixed two things, wrapped a function over it

DEFINE_PATCH_FUNCTION ~FJ_SPL_ITM_REINDEX~ BEGIN

  PATCH_IF !(~%SOURCE_FILE%~ STRING_MATCHES_REGEXP ~^.+\.spl~) BEGIN
    hs = 0x28
    WRITE_LONG 0xc ~-1~ //Identified name
    WRITE_LONG 0x54 ~-1~ //Identified description
    PATCH_FOR_EACH tz IN 0x44 0x48 0x58 0x5c BEGIN
      WRITE_LONG tz 0
    END
  END ELSE PATCH_IF !(~%SOURCE_FILE%~ STRING_MATCHES_REGEXP ~^.+\.itm~) BEGIN
    hs = 0x38
  END
  READ_LONG 0x64 hf //Extended header offset
  READ_SHORT 0x68 hc //Extended header count
  READ_LONG 0x6a fb //Feature block table offset
  READ_SHORT 0x70 fc //Feature block count
  PATCH_IF ((hf > fb) AND (hc > 0)) BEGIN // Ardanis: fixed "hc > 1" to "hc > 0"
    READ_ASCII hf ~eh~ ELSE ~fail~ (hs * hc)
    PATCH_IF (~%eh%~ STRING_EQUAL ~fail~) BEGIN
      WHILE ((~%eh%~ STRING_EQUAL ~fail~) AND (hc > 0)) BEGIN
        READ_ASCII hf ~eh~ ELSE ~fail~ (hs * hc)
        hc -= 1
      END
    END
    DELETE_BYTES hf (hs * hc)
    hf = 0x72
    WRITE_LONG 0x64 hf
    WRITE_SHORT 0x68 hc
    fb = (0x72 + (hs * hc))
    WRITE_LONG 0x6a fb
    PATCH_IF !(~%eh%~ STRING_EQUAL ~fail~) BEGIN
      INSERT_BYTES hf (hs * hc)
      WRITE_ASCIIE hf ~%eh%~
    END
  END ELSE PATCH_IF ((hf != 0x72) AND (hc = 0)) BEGIN
    hf = 0x72
    WRITE_LONG 0x64 hf
  END
  FOR (i1 = 0; i1 < (hs * hc); i1 += hs) BEGIN
    WRITE_SHORT (hf + i1 + 0x20) fc
    READ_SHORT (hf + i1 + 0x1e) cx
    fc += cx
  END
  PATCH_IF (SOURCE_SIZE > (0x72 + (hs * hc) + (0x30 * fc))) BEGIN
    DELETE_BYTES (0x72 + (hs * hc) + (0x30 * fc)) (SOURCE_SIZE - (0x72 + (hs * hc) + (0x30 * fc)))
  END

  // added by Ardanis
  WRITE_SHORT 0x6e 0

END // end of function


/////                                                  \\\\\
///// cd_make_subspell                                 \\\\\
/////                                                  \\\\\

DEFINE_PATCH_MACRO ~cd_make_subspell~ BEGIN
  WRITE_LONG 0x08 "-1" // blank name
  WRITE_LONG 0x50 "-1" // blank desc
  WRITE_ASCII 0x22 ~~ #6 // blank casting anim, school, secondary
  LPF ALTER_HEADER INT_VAR projectile = 1 END
  LPF ALTER_EFFECT INT_VAR power = 0 resist_dispel = 0 savingthrow = 0 END
END

/////                                                  \\\\\
///// cd_move_actor action/patch function              \\\\\
/////                                                  \\\\\

DEFINE_ACTION_FUNCTION cd_move_actor

  INT_VAR old_x = "-1" // old coordinates for matching
          old_y = "-1"
          new_x = "-1" // new coordinates
          new_y = "-1"
  STR_VAR area  = "none" // area to patch w/o .are extension

BEGIN

  COPY_EXISTING ~%area%.are~ ~override~
    LPF cd_move_actor INT_VAR old_x old_y new_x new_y END
    BUT_ONLY IF_EXISTS // formally, should ACTION_IF with a WARNING if %area%.are not found... but meh

END

DEFINE_PATCH_FUNCTION cd_move_actor

  INT_VAR old_x = "-1" // old coordinates for matching
          old_y = "-1"
          new_x = "-1" // new coordinates
          new_y = "-1"
BEGIN

  READ_LONG  0x54 actor_off
  READ_SHORT 0x58 actor_num
  FOR (index = 0 ; index < actor_num ; ++index) BEGIN
    READ_SHORT (actor_off + 0x20 + (index * 0x110)) test_x
    READ_SHORT (actor_off + 0x22 + (index * 0x110)) test_y
    PATCH_IF ((test_x = old_x) AND (test_y = old_y)) BEGIN
      WRITE_SHORT (actor_off + 0x20 + (index * 0x110)) new_x // location
      WRITE_SHORT (actor_off + 0x22 + (index * 0x110)) new_y
      WRITE_SHORT (actor_off + 0x24 + (index * 0x110)) new_x // destination
      WRITE_SHORT (actor_off + 0x26 + (index * 0x110)) new_y
    END
  END

END

/////                                                  \\\\\
///// cd_define_area_vertices                          \\\\\
/////                                                  \\\\\

/*
angel found a number of opened doors with broken/missing vertices, and fixes
them in his MiH Fixes & Restorations. Unfortunately, they were fixed with SFO
so they needed to be converted to bogstandard functions. This function allow
you to alter the vertices of any area structure--containers, regions, or the
four sets of vertices used by doors--by deleting the existing vertices and
using an external cd_define_area_vertices_array for the new vertices. This
array *must* be defined prior to the function launch.

The bounding box and launch points are optional to specify, though the
bounding box values are ignored for impeded door vertices since they don't
have a bounding box.
*/

DEFINE_PATCH_FUNCTION cd_define_area_vertices
  INT_VAR bounding_left   = "-1" // optional
          bounding_top    = "-1" // optional
          bounding_right  = "-1" // optional
          bounding_bottom = "-1" // optional
          launch_point_x  = "-1" // optional
          launch_point_y  = "-1" // optional
  STR_VAR struct_name  = ~~ // required: name of the door/region/container to be patched
          struct_type  = ~~ // required with allowed values: container, region, door_open, door_closed, door_impeded_open, door_impeded_closed
BEGIN

  SET door_internal = "-1"
  PATCH_IF ("%struct_type%" STRING_COMPARE_REGEXP "door_\(open\|closed\|impeded_open\|impeded_closed\)" = 0) BEGIN // any door
    READ_LONG  0xa4 struct_num
    READ_LONG  0xa8 struct_off
    SET struct_length = 0xc8
    SET local_launch_off = 0x74
    PATCH_IF ("%struct_type%" STRING_COMPARE_CASE "door_open" = 0) BEGIN // open door
      SET local_bound_off = 0x38
      SET local_vert_idx_off = 0x2c
      SET local_vert_num_off = 0x30
      SET door_internal = 4
    END ELSE
    PATCH_IF ("%struct_type%" STRING_COMPARE_CASE "door_closed" = 0) BEGIN // closed door
      SET local_bound_off = 0x40
      SET local_vert_idx_off = 0x34
      SET local_vert_num_off = 0x32
      SET door_internal = 3
    END ELSE
    PATCH_IF ("%struct_type%" STRING_COMPARE_CASE "door_impeded_open" = 0) BEGIN // open, impeded door
      SET local_bound_off = 0
      SET local_vert_idx_off = 0x48
      SET local_vert_num_off = 0x4c
      SET door_internal = 2
    END ELSE BEGIN // closed, impeded door
      SET local_bound_off = 0
      SET local_vert_idx_off = 0x50
      SET local_vert_num_off = 0x4e
      SET door_internal = 1
    END
  END ELSE
  PATCH_IF ("%struct_type%" STRING_COMPARE_CASE "container" = 0) BEGIN // container
    SET local_bound_off = 0x38
    SET local_vert_idx_off = 0x54
    SET local_vert_num_off = 0x50
    SET local_launch_off = 0x34
    READ_SHORT 0x74 struct_num
    READ_LONG  0x70 struct_off
    SET struct_length = 0xc0
    SET door_internal = 0
  END ELSE
  PATCH_IF ("%struct_type%" STRING_COMPARE_CASE "region" = 0) BEGIN // region/trigger
    SET local_bound_off = 0x22
    SET local_vert_idx_off = 0x2c
    SET local_vert_num_off = 0x2a
    SET local_launch_off = 0x70
    READ_SHORT 0x5a struct_num
    READ_LONG  0x5c struct_off
    SET struct_length = 0xc4
    SET door_internal = 0
  END
  PATCH_IF door_internal < 0 BEGIN
    PATCH_PRINT ~ == No changes made with cd_define_area_vertices: Unknown structure type specified (%struct_type%)~
  END ELSE BEGIN
    SET vert_delta = 0
    READ_LONG  0x7c vert_off
    READ_SHORT 0x80 vert_num
    FOR (index = 0 ; index < struct_num ; ++index) BEGIN
      READ_ASCII (struct_off + 0x00 + (index * struct_length)) name_check
      PATCH_IF ("%name_check%" STRING_COMPARE_CASE "%struct_name%") BEGIN // NOT the matched door/region/container
        PATCH_IF vert_delta != 0 BEGIN // don't bother if number of vertices hasn't changed (yet)
          PATCH_IF door_internal = 0 BEGIN // update container/region
            WRITE_LONG (struct_off + local_vert_idx_off + (index * struct_length)) THIS + vert_delta // update vertex index
          END ELSE BEGIN // update four door indices
            WRITE_LONG (struct_off + 0x2c + (index * struct_length)) THIS + vert_delta // open door vertex index
            WRITE_LONG (struct_off + 0x34 + (index * struct_length)) THIS + vert_delta // closed door vertex index
            WRITE_LONG (struct_off + 0x48 + (index * struct_length)) THIS + vert_delta // impeded-open door vertex index
            WRITE_LONG (struct_off + 0x50 + (index * struct_length)) THIS + vert_delta // impeded-closed door vertex index
          END
        END
      END ELSE BEGIN // matched door/region/container
        PATCH_IF local_bound_off != 0 BEGIN // skip for impeded doors
          PATCH_IF bounding_left >= 0 BEGIN // only if set
            WRITE_SHORT (struct_off + local_bound_off + 0x00 + (index * struct_length)) bounding_left   // set the new bounding box
          END
          PATCH_IF bounding_top >= 0 BEGIN // only if set
            WRITE_SHORT (struct_off + local_bound_off + 0x02 + (index * struct_length)) bounding_top    // set the new bounding box
          END
          PATCH_IF bounding_right >= 0 BEGIN // only if set
            WRITE_SHORT (struct_off + local_bound_off + 0x04 + (index * struct_length)) bounding_right  // set the new bounding box
          END
          PATCH_IF bounding_bottom >= 0 BEGIN // only if set
            WRITE_SHORT (struct_off + local_bound_off + 0x06 + (index * struct_length)) bounding_bottom // set the new bounding box
          END
        END
        PATCH_IF launch_point_x >= 0 BEGIN // only if set
          WRITE_SHORT (struct_off + local_launch_off + 0x00 + (index * struct_length)) launch_point_x    // set the new x launch coordinates
        END
        PATCH_IF launch_point_y >= 0 BEGIN // only if set
          WRITE_SHORT (struct_off + local_launch_off + 0x02 + (index * struct_length)) launch_point_y    // set the new y launch coordinates
        END
        READ_LONG   (struct_off + local_vert_idx_off + (index * struct_length)) struct_vert_idx
        READ_SHORT  (struct_off + local_vert_num_off + (index * struct_length)) struct_vert_num
        PATCH_IF struct_vert_num != 0 BEGIN // delete old vertices first
          DELETE_BYTES (vert_off + (0x04 * struct_vert_idx)) (struct_vert_num * 0x04)
          SET vert_delta -= struct_vert_num
          SET struct_vert_num = 0
        END
        PATCH_PHP_EACH cd_define_area_vertices_array AS coords => foo BEGIN
          INSERT_BYTES (vert_off + 0x00 + (0x04 * (struct_vert_num + struct_vert_idx))) 0x04
          WRITE_SHORT  (vert_off + 0x00 + (0x04 * (struct_vert_num + struct_vert_idx))) coords_0
          WRITE_SHORT  (vert_off + 0x02 + (0x04 * (struct_vert_num + struct_vert_idx))) coords_1
          SET struct_vert_num += 1
          SET vert_delta += 1
        END
        WRITE_SHORT  (struct_off + local_vert_num_off + (index * struct_length)) struct_vert_num
        // since doors have four vertex indices, may need additional vertex index updates for anything other than the last one (impeded-closed)
        PATCH_IF door_internal > 1 BEGIN      // impeded-open, closed, or open
          WRITE_LONG (struct_off + 0x50 + (index * struct_length)) THIS + vert_delta     // impeded-closed index
          PATCH_IF door_internal > 2  BEGIN   // closed or open
            WRITE_LONG (struct_off + 0x48 + (index * struct_length)) THIS + vert_delta   // impeded-open index
            PATCH_IF door_internal > 3  BEGIN // open
              WRITE_LONG (struct_off + 0x34 + (index * struct_length)) THIS + vert_delta // closed index
            END
          END
        END // bonus door check
      END // match name check
    END // end structure loop

    // now, to check everything else that uses vertices and update their indices if are listed after the new insertions/deletions
    PATCH_IF vert_delta != 0 BEGIN // don't bother if same number of vertices
      PATCH_FOR_EACH offset IN 0x54 0x5c 0x60 0x68 0x70 0x78 /* 0x7c */ 0x84 0x88 0x90 0xa0 0xa8 0xb0 0xb8 0xbc 0xc0 0xc4 0xcc BEGIN
        READ_LONG offset off_check
        PATCH_IF off_check > vert_off BEGIN // if section is after vertices, adjust accordingly
          WRITE_LONG offset (THIS + (0x04 * vert_delta))
        END
      END
      PATCH_IF ("%struct_type%" STRING_COMPARE_CASE "region") BEGIN // update region indices for containers/door patches
        READ_SHORT 0x5a region_num
        READ_LONG  0x5c region_off
        FOR (index = 0 ; index < region_num ; ++index) BEGIN
          READ_LONG (region_off + 0x2c + (index * 0xc4)) vert_idx
          PATCH_IF vert_idx > struct_vert_idx BEGIN
            WRITE_LONG (region_off + 0x2c + (index * 0xc4)) vert_idx + vert_delta
          END
        END
      END
      PATCH_IF ("%struct_type%" STRING_COMPARE_CASE "container") BEGIN // update container indices for region/door patches
        READ_SHORT 0x74 cont_num
        READ_LONG  0x70 cont_off
        FOR (index = 0 ; index < cont_num ; ++index) BEGIN
          READ_LONG (cont_off + 0x50 + (index * 0xc0)) vert_idx
          PATCH_IF vert_idx > struct_vert_idx BEGIN
            WRITE_LONG (cont_off + 0x50 + (index * 0xc0)) vert_idx + vert_delta
          END
        END
      END
      PATCH_IF !door_internal BEGIN // update door indices for container/region patches
        READ_LONG 0xa4 door_num
        READ_LONG 0xa8 door_off
        FOR (index = 0 ; index < door_num ; ++index) BEGIN
          PATCH_FOR_EACH local_off IN 0x2c 0x34 0x48 0x50 BEGIN // checks open door index, closed door index, impeded-open index, impeded-closed index
            READ_LONG (door_off + local_off + (index * 0xc8)) vert_idx
            PATCH_IF vert_idx > struct_vert_idx BEGIN
              WRITE_LONG (door_off + local_off + (index * 0xc8)) vert_idx + vert_delta
            END
          END
        END
      END
      WRITE_SHORT 0x80 vert_num + vert_delta
    END // vert_delta check

  END // end valid structure check

END

/////                                                  \\\\\
///// spell extension library                          \\\\\
/////                                                  \\\\\

/*

The CD_LEVEL_SELECT-O-MATIC invokes the CD_EXTEND-O-MATIC or
CD_TRIM-O-MATIC function as necessary to extend or trim the selected spell
to the desired level cap. Both TRIM and EXTEND can be invoked directly.

* Define round and cap variables before INCLUDEing these *

more documentation here:
https://www.gibberlings3.net/forums/topic/28835-toss-your-semi-useful-weidu-macros-here/page/13/#comment-332943

used:
  Spell-50, as spell50/lib/cd_level_select-o-matic.tpa [symbolic link]
  The Divine Remix, as divine_remix/lib/cd_level_select-o-matic.tpa [symbolic link]
  Sword and Fist, as sword_and_fist/lib/cd_level_select-o-matic.tpa [symbolic link]
  SP Collection, as spstuff/lib/cd_level_select-o-matic.tpa [symbolic link]

version history:
  unk: creation of the original CD_EXTEND-O-MATIC
  12/30/23: Added level select and trim macros; expended extend; bundled together for Spell-50
  2/6/25: fixed bug where TRIM-O-MATIC never initialized the abil_delta variable

platform:
  everything except pst and iwd2

*/

/////                                                  \\\\\
///// CD_LEVEL_SELECT-O-MATIC, patent pending          \\\\\
/////                                                  \\\\\

// this function creates headers and does basic duration extensions to level 30; written for inwd-in-bg2 ages ago
DEFINE_PATCH_FUNCTION CD_LEVEL_SELECT-O-MATIC
  INT_VAR base_dur       = 0     // constant to add to all durations
          step_dur       = round // how much duration to add to each consecutive header
          step_size      = 1     // how many levels between headers
          level_cap      = cap   // stop extending at level
          min_dur        = 4     // ignore effects with durations less than this (e.g. cosmetics)
          dur_special    = 0     // just add step_dur to existing effects (ignore base_dur)
          min_lev_alt    = 0     // if extending from level 1, use this value as its minimum level instead (e.g. fifth slevel spell with only one header, use 9 here)
          base_dmg_rolls = 0     // base roll damage
          base_dmg_fixed = 0     // base fixed damage
          damage_rolls   = 0     // +die roll damage per level
          damage_fixed   = 0     // +fixed damage per level
          save_for_half  = 0     // if we need to split damage for non-ee
          damage_special = 0     // just add damage_rolls/damage_fixed to existing effects (ignore base_dmg_rolls, base_dmg_fixed)
          min_abil       = 2     // don't do anything unless the spell has at least this many headers
  RET     abil_delta
BEGIN

  READ_SHORT 0x68 abil_num
  PATCH_IF abil_num >= min_abil BEGIN
    READ_LONG  0x64 abil_off
    READ_SHORT (abil_off + 0x10 + (0x28 * (abil_num - 1))) last_level // read level of last ability
    PATCH_IF last_level > level_cap BEGIN
      LPF CD_TRIM-O-MATIC INT_VAR level_cap RET abil_delta END
    END ELSE
    PATCH_IF last_level < level_cap BEGIN
      LPF CD_EXTEND-O-MATIC INT_VAR base_dur step_dur step_size level_cap min_dur dur_special min_lev_alt base_dmg_rolls
                                    base_dmg_fixed damage_rolls damage_fixed save_for_half damage_special RET abil_delta END
    END ELSE
    PATCH_IF last_level = level_cap BEGIN
      SET abil_delta = 0
    END
  END ELSE BEGIN
    SET abil_delta = 0
  END

END

/////                                                  \\\\\
///// CD_EXTEND-O-MATIC, patent pending                \\\\\
/////                                                  \\\\\

// this function creates headers and does basic duration extensions to level 30; written for inwd-in-bg2 ages ago
// added abil_delta tracking
DEFINE_PATCH_FUNCTION CD_EXTEND-O-MATIC
  INT_VAR base_dur       = 0     // constant to add to all durations
          step_dur       = round // how much duration to add to each consecutive header
          step_size      = 1     // how many levels between headers
          level_cap      = cap   // stop extending at level
          min_dur        = 4     // ignore effects with durations less than this (e.g. cosmetics)
          dur_special    = 0     // just add step_dur to existing effects (ignore base_dur)
          min_lev_alt    = 0     // if extending from level 1, use this value as its minimum level instead (e.g. fifth slevel spell with only one header, use 9 here)
          base_dmg_rolls = 0     // base roll damage
          base_dmg_fixed = 0     // base fixed damage
          damage_rolls   = 0     // +die roll damage per level
          damage_fixed   = 0     // +fixed damage per level
          save_for_half  = 0     // if we need to split damage for non-ee: 0=no split, 1=split with odd totals going to no-save half, 2=split with odd totals going to save half
          damage_special = 0     // just add damage_rolls/damage_fixed to existing effects (ignore base_dmg_rolls, base_dmg_fixed)
  RET     abil_delta
BEGIN

  SET abil_delta = 0
  READ_LONG  0x64 abil_off
  READ_SHORT 0x68 abil_num
  READ_LONG  0x6a fx_off
  READ_SHORT (abil_off + 0x10 + (0x28 * (abil_num - 1))) min_lev // read level of last ability
  // fudge factor is to determine which half of damage gets the full die when adding 1 per level
  SET save_fudge_fixed = 0 SET save_fudge_rolls = 0 SET nonsave_fudge_fixed = 0 SET nonsave_fudge_rolls = 0
  PATCH_IF save_for_half BEGIN
    PATCH_MATCH save_for_half WITH
      2 BEGIN SET save_fudge_fixed = 1 SET save_fudge_rolls = 1 END
      3 BEGIN SET save_fudge_rolls = 1 SET nonsave_fudge_fixed = 1 END
      4 BEGIN SET save_fudge_fixed = 1 SET nonsave_fudge_rolls = 1  END
      DEFAULT SET nonsave_fudge_fixed = 1 SET nonsave_fudge_rolls = 1 // 1, or non-valid
    END
  END
  PATCH_IF ((min_lev = 1) AND (min_lev_alt != 0)) BEGIN SET min_lev = min_lev_alt END
  FOR (index = min_lev + step_size ; index < (level_cap + 1) ; index = index + step_size) BEGIN
    READ_ASCII (abil_off +        (0x28 * (abil_num - 1))) abil (0x28) // read entire ability
    READ_SHORT (abil_off + 0x1e + (0x28 * (abil_num - 1))) abil_fx_num
    READ_SHORT (abil_off + 0x20 + (0x28 * (abil_num - 1))) abil_fx_idx
    READ_ASCII (fx_off +        (0x30 * abil_fx_idx)) effects (abil_fx_num * 0x30) // read entire fx block
    INSERT_BYTES (fx_off +        (0x30 * (abil_fx_idx + abil_fx_num))) (abil_fx_num * 0x30) // insert bytes for new ability
    WRITE_ASCIIE (fx_off +        (0x30 * (abil_fx_idx + abil_fx_num))) "%effects%"          // write in effects block
    // if damage_special & save_for_half, we use the first loop only to gather total damage between the split damage opcodes, then use it in a second loop
    PATCH_IF damage_special BEGIN
      SET special_fixed = 0
      SET special_rolls = 0
    END
    FOR (index2 = 0 ; index2 < abil_fx_num ; ++index2) BEGIN
      READ_BYTE (fx_off + 0x0c + (0x30 * (abil_fx_idx + abil_fx_num + index2))) timing
      READ_LONG (fx_off + 0x0e + (0x30 * (abil_fx_idx + abil_fx_num + index2))) duration
      PATCH_IF ((duration > min_dur) AND (timing < 10)) BEGIN // exclude instant/cosmetic efects, skip durations in ticks
        PATCH_IF dur_special = 1 BEGIN
          SET new_dur = duration + step_dur
        END ELSE BEGIN
          SET new_dur = (base_dur + (index * step_dur))
        END
        WRITE_LONG (fx_off + 0x0e + (0x30 * (abil_fx_idx + abil_fx_num + index2))) new_dur // adjust durations
      END
      PATCH_IF damage_rolls OR damage_fixed BEGIN // if any scaling damage
        SET new_fixed = (base_dmg_fixed + (index * damage_fixed))
        SET new_rolls = (base_dmg_rolls + (index * damage_rolls))
        READ_SHORT (fx_off +        (0x30 * (abil_fx_idx + abil_fx_num + index2))) opcode
        PATCH_IF opcode = 12 BEGIN // damage
          READ_LONG (fx_off + 0x2c + (0x30 * (abil_fx_idx + abil_fx_num + index2))) special
          PATCH_IF (save_for_half AND ((special & BIT8) = 0)) BEGIN // if we're saving for half and there's no EE save-for-half flag, split damage
            PATCH_IF damage_special BEGIN
              SET special_fixed = special_fixed + LONG_AT (fx_off + 0x04 + (0x30 * (abil_fx_idx + abil_fx_num + index2)))
              SET special_rolls = special_rolls + LONG_AT (fx_off + 0x1c + (0x30 * (abil_fx_idx + abil_fx_num + index2)))
            END ELSE BEGIN
              READ_LONG (fx_off + 0x24 + (0x30 * (abil_fx_idx + abil_fx_num + index2))) save // have to account for non-EE damage split
              PATCH_IF ((save & (BIT0 + BIT1 + BIT2 + BIT3 + BIT4)) = 0) BEGIN // 1/2 damage that always happens
                WRITE_LONG (fx_off + 0x04 + (0x30 * (abil_fx_idx + abil_fx_num + index2))) ((new_fixed + nonsave_fudge_fixed) / 2)
                WRITE_LONG (fx_off + 0x1c + (0x30 * (abil_fx_idx + abil_fx_num + index2))) ((new_rolls + nonsave_fudge_rolls) / 2)
              END ELSE BEGIN
                WRITE_LONG (fx_off + 0x04 + (0x30 * (abil_fx_idx + abil_fx_num + index2))) ((new_fixed + save_fudge_fixed) / 2)
                WRITE_LONG (fx_off + 0x1c + (0x30 * (abil_fx_idx + abil_fx_num + index2))) ((new_rolls + save_fudge_rolls) / 2)
              END
            END
          END ELSE BEGIN // either no save-for-half or on EE with its save-for-half flag
            PATCH_IF damage_special BEGIN
              WRITE_LONG (fx_off + 0x04 + (0x30 * (abil_fx_idx + abil_fx_num + index2))) (THIS + damage_fixed)
              WRITE_LONG (fx_off + 0x1c + (0x30 * (abil_fx_idx + abil_fx_num + index2))) (THIS + damage_rolls)
            END ELSE BEGIN
              WRITE_LONG (fx_off + 0x04 + (0x30 * (abil_fx_idx + abil_fx_num + index2))) new_fixed
              WRITE_LONG (fx_off + 0x1c + (0x30 * (abil_fx_idx + abil_fx_num + index2))) new_rolls
            END
          END
        END
      END
    END // closes effects loop
    PATCH_IF (damage_special AND (special_fixed OR special_rolls)) BEGIN
      SET new_fixed = (special_fixed + damage_fixed)
      SET new_rolls = (special_rolls + damage_rolls)
      FOR (index2 = 0 ; index2 < abil_fx_num ; ++index2) BEGIN
        READ_SHORT (fx_off +        (0x30 * (abil_fx_idx + abil_fx_num + index2))) opcode
        PATCH_IF opcode = 12 BEGIN // damage
          READ_LONG (fx_off + 0x2c + (0x30 * (abil_fx_idx + abil_fx_num + index2))) special
          PATCH_IF (save_for_half AND ((special & BIT8) = 0)) BEGIN // if we're saving for half and there's no EE save-for-half flag, split damage
            READ_LONG (fx_off + 0x24 + (0x30 * (abil_fx_idx + abil_fx_num + index2))) save // have to account for non-EE damage split
            PATCH_IF ((save & (BIT0 + BIT1 + BIT2 + BIT3 + BIT4)) = 0) BEGIN // 1/2 damage that always happens
              WRITE_LONG (fx_off + 0x04 + (0x30 * (abil_fx_idx + abil_fx_num + index2))) ((new_fixed + nonsave_fudge_fixed) / 2)
              WRITE_LONG (fx_off + 0x1c + (0x30 * (abil_fx_idx + abil_fx_num + index2))) ((new_rolls + nonsave_fudge_rolls) / 2)
            END ELSE BEGIN
              WRITE_LONG (fx_off + 0x04 + (0x30 * (abil_fx_idx + abil_fx_num + index2))) ((new_fixed + save_fudge_fixed) / 2)
              WRITE_LONG (fx_off + 0x1c + (0x30 * (abil_fx_idx + abil_fx_num + index2))) ((new_rolls + save_fudge_rolls) / 2)
            END
          END
        END
      END // closes second effects loop for damage_special
    END // end patch_if for damage_special
    INSERT_BYTES (abil_off +        (0x28 * abil_num)) 0x28 // insert new ability
    WRITE_ASCIIE (abil_off +        (0x28 * abil_num)) "%abil%"
    WRITE_SHORT  (abil_off + 0x10 + (0x28 * abil_num)) index
    WRITE_SHORT  (abil_off + 0x20 + (0x28 * abil_num)) (abil_fx_idx + abil_fx_num)
    SET abil_num += 1
    SET abil_delta += 1
    SET fx_off   += 0x28
  END
  WRITE_SHORT 0x68 abil_num
  WRITE_LONG  0x6a fx_off

END

/////                                                  \\\\\
///// CD_TRIM-O-MATIC, patent pending                  \\\\\
/////                                                  \\\\\

// this function creates headers and does basic duration extensions to level 30; written for inwd-in-bg2 ages ago
DEFINE_PATCH_FUNCTION CD_TRIM-O-MATIC
  INT_VAR level_cap   = cap // delete headers with a minmum level above this
  RET     abil_delta
BEGIN

  SET abil_delta = 0
  READ_SHORT 0x68 abil_num
  PATCH_IF abil_num > 1 BEGIN // *always* leave at least one ability
    READ_LONG  0x64 abil_off
    READ_SHORT (abil_off + 0x10 + (0x28 * (abil_num - 1))) last_level // read level of last ability
    PATCH_IF last_level > level_cap BEGIN // if last level is under the cap, nothing further to be done
      READ_LONG  0x6a fx_off
      READ_SHORT (abil_off + 0x1e + (0x28 * (abil_num - 1))) last_abil_fx_num
      READ_SHORT (abil_off + 0x20 + (0x28 * (abil_num - 1))) last_abil_fx_idx
      FOR (index = 1 ; index < abil_num ; ++index) BEGIN // now find the first ability over the cap; start at one to preserve at least one header
        READ_SHORT (abil_off + 0x10 + (0x28 * index)) level // read level of ability
        PATCH_IF level > level_cap BEGIN
          READ_SHORT (abil_off + 0x20 + (0x28 * index)) first_abil_fx_idx
          SET abil_first = index
          SET index = abil_num // kill loop
        END
      END
      SET fx_length = (0x30 * (last_abil_fx_idx + last_abil_fx_num - first_abil_fx_idx))
      DELETE_BYTES (fx_off + (first_abil_fx_idx * 0x30)) fx_length // delete all effects attached to these abilities
      SET abil_delta = (abil_first - abil_num)
      SET abil_length = ((abil_num - abil_first) * 0x28)
      DELETE_BYTES (fx_off - abil_length) (abil_length) // now delete the abilities
      WRITE_LONG 0x6a fx_off - abil_length // update effects offset to acocunt for deleted abilities
      WRITE_SHORT 0x68 abil_first // update ability count
    END
  END

END

/////                                                  \\\\\
///// x-force                                          \\\\\
/////                                                  \\\\\

/*

 ALTER_, CLONE_, and DELETE_EFFECT are pretty useful functions, but they (rather infamously)
 don't allow you to write in negative numbers into the effects you're modifying. I've always
 wanted to revisit these functions and address this, but it was always on my 'one of these
 days' to-do list and more or less ignored. Until today, when I was inspired to address this,
 and quite a bit more.

Introducing the _EX versions of these effects: ALTER_EFFECT_EX, CLONE_EFFECT_EX, and
DELETE_EFFECT_EX. These function exactly the same way as the originals, but have additional
variables that make these exceptionally flexible.

 I wrote an ALTER_HEADER function as well, but unlike my other functions, it never made it
 into WeiDU proper. I've added an ALTER_HEADER_EX variant as well, e.g. let's say you wanted
 to give spears a bit of a boost by giving them a +1 damage bonus:

more documentation here:
https://www.gibberlings3.net/forums/topic/36242-expanded-alterclonedelete_effect-functions/

used:

version history:
  12/12/22: initial coding

platform:
  all

*/

/////                                                  \\\\\
///// CLONE_EFFECT_EX                                  \\\\\
/////                                                  \\\\\

DEFINE_PATCH_FUNCTION CLONE_EFFECT_EX

  // defines what we're going to check
  INT_VAR check_globals       = 1
          check_headers       = 1
          header              = "-1"
          header_type         = "-1"
          multi_match         = 999
          verbose             = 0
          silent              = 0

  // variables for finding the effect to match
          match_opcode        = "-1"
          match_target        = "-1"
          match_power         = "-1"
          match_parameter1    = "-1"
          match_parameter2    = "-1"
          match_timing        = "-1"
          match_resist_dispel = "-1"
          match_duration      = "-1"
          match_duration_high = "-1"
          match_probability1  = "-1"
          match_probability2  = "-1"
          match_dicenumber    = "-1"
          match_dicesize      = "-1"
          match_savingthrow   = "-1"
          match_savebonus     = "-11"
          match_special       = "-1"

  // variables for the new effect
          opcode              = "-1"
          target              = "-1"
          power               = "-1"
          parameter1          = "-1"
          parameter2          = "-1"
          timing              = "-1"
          resist_dispel       = "-1"
          duration            = "-1"
          duration_high       = "-1"
          probability1        = "-1"
          probability2        = "-1"
          dicenumber          = "-1"
          dicesize            = "-1"
          savingthrow         = "-1"
          savebonus           = "-11"
          special             = "-1"

  // same for match and new STR_VAR
  STR_VAR match_resource      = "SAME"
          resource            = "SAME"
          insert              = "above"

  // defines what we're going to check
          header_type_ex         = ~((header = index) OR (header < 0))~

  // string variables for finding the effect to match
          match_opcode_ex        = ~((match_opcode        = o_opcode)        OR (match_opcode < 0))~
          match_target_ex        = ~((match_target        = o_target)        OR (match_target < 0))~
          match_power_ex         = ~((match_power         = o_power)         OR (match_power < 0))~
          match_parameter1_ex    = ~((match_parameter1    = o_parameter1)    OR (match_parameter1 < 0))~
          match_parameter2_ex    = ~((match_parameter2    = o_parameter2)    OR (match_parameter2 < 0))~
          match_timing_ex        = ~((match_timing        = o_timing)        OR (match_timing < 0))~
          match_resist_dispel_ex = ~((match_resist_dispel = o_resist_dispel) OR (match_resist_dispel < 0))~
          match_duration_ex      = ~((match_duration      = o_duration)      OR (match_duration < 0))~
          match_probability1_ex  = ~((match_probability1  = o_probability1)  OR (match_probability1 < 0))~
          match_probability2_ex  = ~((match_probability2  = o_probability2)  OR (match_probability2 < 0))~
          match_dicenumber_ex    = ~((match_dicenumber    = o_dicenumber)    OR (match_dicenumber < 0))~
          match_dicesize_ex      = ~((match_dicesize      = o_dicesize)      OR (match_dicesize < 0))~
          match_savingthrow_ex   = ~((match_savingthrow   = o_savingthrow)   OR (match_savingthrow < 0))~
          match_savebonus_ex     = ~((match_savebonus     = o_savebonus)     OR (match_savebonus < "-10"))~
          match_special_ex       = ~((match_special       = o_special)       OR (match_special < 0))~
          match_resource_ex      = ~(("%match_resource%" STRING_COMPARE_CASE "%o_resource%" = 0) OR ("%match_resource%" STRING_COMPARE_CASE "SAME" = 0))~

  // stringvariables for the new effect
          opcode_ex              = "SAME"
          target_ex              = "SAME"
          power_ex               = "SAME"
          parameter1_ex          = "SAME"
          parameter2_ex          = "SAME"
          timing_ex              = "SAME"
          resist_dispel_ex       = "SAME"
          duration_ex            = "SAME"
          probability1_ex        = "SAME"
          probability2_ex        = "SAME"
          dicenumber_ex          = "SAME"
          dicesize_ex            = "SAME"
          savingthrow_ex         = "SAME"
          savebonus_ex           = "SAME"
          special_ex             = "SAME"
          resource_ex            = "SAME"

BEGIN

  // set variables and offsets based on the file type
  SET new_fx = 0
  READ_ASCII 0 sig ELSE "fail" (4)
  READ_ASCII 0x04 version (4)
  PATCH_MATCH "%sig%" WITH
    "SPL "
    BEGIN
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V2.0" = 0) BEGIN // iwd2, spl 2.0
        SET min_size       = 0x82
      END ELSE BEGIN
        SET min_size       = 0x72
      END
      READ_LONG   0x6a fx_off   ELSE 0
      SET counter_offset = 0x70
      SET abil_length    = 0x28
      SET fx_type        = 0
      READ_LONG   0x64 abil_off ELSE 0
      READ_SHORT  0x68 abil_num ELSE 0
    END

    "ITM "
    BEGIN
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V1.1" = 0) BEGIN // pst, itm v1.1
        SET min_size       = 0x9a
      END ELSE BEGIN
        SET min_size       = 0x72
      END
      READ_LONG   0x6a fx_off   ELSE 0
      SET counter_offset = 0x70
      SET abil_length    = 0x38
      SET fx_type        = 0
      READ_LONG   0x64 abil_off ELSE 0
      READ_SHORT  0x68 abil_num ELSE 0
    END

    "CRE "
    BEGIN
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V1.2" = 0) BEGIN // pst, cre v1.2
        SET min_size       = 0x378
        READ_LONG  0x368 fx_off
        SET counter_offset = 0x36c
      END ELSE
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V2.2" = 0) BEGIN // iwd2, cre v2.2
        SET min_size       = 0x62e
        READ_LONG  0x61e fx_off
        SET counter_offset = 0x622
      END ELSE
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V9.0" = 0) BEGIN // iwd, cre v9.0
        SET min_size       = 0x33c
        READ_LONG  0x32c fx_off
        SET counter_offset = 0x330
      END ELSE BEGIN                                               // everything else, cre v1.0
        SET min_size = 0x2d4
        READ_LONG  0x2c4 fx_off
        SET counter_offset = 0x2c8
      END
      SET abil_off = 0 // basically prevents the ability effect loop
      SET abil_num = 0
      SET abil_length = 0
      SET check_globals = 1
      READ_BYTE 0x33 fx_type ELSE 2
    END

    "fail"
    BEGIN
      PATCH_WARN "ERROR: CLONE_EFFECT_EX does not think %SOURCE_FILE% appears to be a valid file"
    END

    DEFAULT
      SET min_size = "-1" // kill macro as the file type is not recognized
      PATCH_WARN "ERROR: CLONE_EFFECT_EX does not support file type %sig%"
  END

  SPRINT o_SOURCE_FILE ~%SOURCE_FILE%~ // preserve original copy vars
  SPRINT o_SOURCE_RES  ~%SOURCE_RES%~
  SPRINT o_DEST_FILE   ~%DEST_FILE%~
  SPRINT o_DEST_RES    ~%DEST_RES%~

  INNER_ACTION BEGIN

<<<<<<<<./inline/clone_effect_ex_macro.tph

DEFINE_PATCH_MACRO clone_effect_ex_macro_working BEGIN

      PATCH_IF (((abil_type = header_type) OR (abil_type < 0) OR (header_type < 0)) AND // only look on the right header types, if specified...
                (REPLACE_header_type_ex) AND                                            // and only on the right # header, if specified
                ((index < 0) OR (check_headers))) BEGIN                                 // if check headers = 0, only re-index
        SET last = 0                              // and only on the right # header, if specified
        SET local_multi = multi_match
        FOR (index2 = 0 ; index2 < (counter - last) ; ++index2) BEGIN

          // read the variables from the current effect
          READ_SHORT (fx_off        + (0x08 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_opcode
          READ_BYTE  (fx_off + 0x02 + (0x0a * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_target
          READ_BYTE  (fx_off + 0x03 + (0x0d * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_power
          READ_LONG  (fx_off + 0x04 + (0x10 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_parameter1
          READ_LONG  (fx_off + 0x08 + (0x10 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_parameter2
          READ_BYTE  (fx_off + 0x0c + (0x10 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_timing
          READ_BYTE  (fx_off + 0x0d + (0x47 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_resist_dispel
          READ_LONG  (fx_off + 0x0e + (0x12 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_duration
          READ_BYTE  (fx_off + 0x12 + (0x12 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_probability1
          READ_BYTE  (fx_off + 0x13 + (0x13 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_probability2
          READ_ASCII (fx_off + 0x14 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_resource
          READ_LONG  (fx_off + 0x1c + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_dicenumber
          READ_LONG  (fx_off + 0x20 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_dicesize
          READ_LONG  (fx_off + 0x24 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_savingthrow
          READ_LONG  (fx_off + 0x28 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_savebonus
          READ_LONG  (fx_off + 0x2c + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_special

          // match ALL these variables, if specified
          PATCH_IF ((REPLACE_match_opcode_ex)        AND
                    (REPLACE_match_target_ex)        AND
                    (REPLACE_match_power_ex)         AND
                    (REPLACE_match_parameter1_ex)    AND
                    (REPLACE_match_parameter2_ex)    AND
                    (REPLACE_match_timing_ex)        AND
                    (REPLACE_match_resist_dispel_ex) AND
                    (REPLACE_match_duration_ex)      AND
                    (REPLACE_match_probability1_ex)  AND
                    (REPLACE_match_probability2_ex)  AND
                    (REPLACE_match_dicenumber_ex)    AND
                    (REPLACE_match_dicesize_ex)      AND
                    (REPLACE_match_savingthrow_ex)   AND
                    (REPLACE_match_savebonus_ex)     AND
                    (REPLACE_match_special_ex)       AND
                    (REPLACE_match_resource_ex))
          BEGIN

            // now that we've got a match, read-and-clone it:
            READ_ASCII   (fx_off        + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) clone (0x30 + (0xd8 * fx_type))
            PATCH_IF ("%insert%" STRING_COMPARE_CASE "below" = 0) BEGIN
              SET base = (fx_off        + ((abil_fx_idx + index2 + 1) * (0x30 + (0xd8 * fx_type))))
            END ELSE
            PATCH_IF ("%insert%" STRING_COMPARE_CASE "first" = 0) BEGIN
              SET base = (fx_off        + (abil_fx_idx * (0x30 + (0xd8 * fx_type))))
            END ELSE
            PATCH_IF ("%insert%" STRING_COMPARE_CASE "last" = 0) BEGIN
              SET base = (fx_off        + ((abil_fx_idx + counter) * (0x30 + (0xd8 * fx_type))))
            END ELSE BEGIN
              SET base = (fx_off        + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type))))
            END
            INSERT_BYTES base (0x30 + (0xd8 * fx_type))
            WRITE_ASCIIE base "%clone%"

            // overwrite the cloned effect with the new variables, if specified
            PATCH_IF ("%opcode_ex%"        STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_SHORT (base        + (0x08 * fx_type)) (REPLACE_opcode_ex)        END ELSE BEGIN
            PATCH_IF (opcode >= 0)        BEGIN WRITE_SHORT (base        + (0x08 * fx_type)) opcode        END END
            PATCH_IF ("%target_ex%"        STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_BYTE  (base + 0x02 + (0x0a * fx_type)) (REPLACE_target_ex)        END ELSE BEGIN
            PATCH_IF (target >= 0)        BEGIN WRITE_BYTE  (base + 0x02 + (0x0a * fx_type)) target        END END
            PATCH_IF ("%power_ex%"         STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_BYTE  (base + 0x03 + (0x0d * fx_type)) (REPLACE_power_ex)         END ELSE BEGIN
            PATCH_IF (power >= 0)         BEGIN WRITE_BYTE  (base + 0x03 + (0x0d * fx_type)) power         END END
            PATCH_IF ("%parameter1_ex%"    STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_LONG  (base + 0x04 + (0x10 * fx_type)) (REPLACE_parameter1_ex)    END ELSE BEGIN
            PATCH_IF (parameter1 >= 0)    BEGIN WRITE_LONG  (base + 0x04 + (0x10 * fx_type)) parameter1    END END
            PATCH_IF ("%parameter2_ex%"    STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_LONG  (base + 0x08 + (0x10 * fx_type)) (REPLACE_parameter2_ex)    END ELSE BEGIN
            PATCH_IF (parameter2 >= 0)    BEGIN WRITE_LONG  (base + 0x08 + (0x10 * fx_type)) parameter2    END END
            PATCH_IF ("%timing_ex%"        STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_BYTE  (base + 0x0c + (0x10 * fx_type)) (REPLACE_timing_ex)        END ELSE BEGIN
            PATCH_IF (timing >= 0)        BEGIN WRITE_BYTE  (base + 0x0c + (0x10 * fx_type)) timing        END END
            PATCH_IF ("%resist_dispel_ex%" STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_BYTE  (base + 0x0d + (0x47 * fx_type)) (REPLACE_resist_dispel_ex) END ELSE BEGIN
            PATCH_IF (resist_dispel >= 0) BEGIN WRITE_BYTE  (base + 0x0d + (0x47 * fx_type)) resist_dispel END END
            PATCH_IF ("%duration_ex%"      STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_LONG  (base + 0x0e + (0x12 * fx_type)) (REPLACE_duration_ex)      END ELSE BEGIN
            PATCH_IF (duration >= 0)      BEGIN WRITE_LONG  (base + 0x0e + (0x12 * fx_type)) duration      END END
            PATCH_IF ("%probability1_ex%"  STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_BYTE  (base + 0x12 + (0x12 * fx_type)) (REPLACE_probability1_ex)  END ELSE BEGIN
            PATCH_IF (probability1 >= 0)  BEGIN WRITE_BYTE  (base + 0x12 + (0x12 * fx_type)) probability1  END END
            PATCH_IF ("%probability2_ex%"  STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_BYTE  (base + 0x13 + (0x13 * fx_type)) (REPLACE_probability2_ex)  END ELSE BEGIN
            PATCH_IF (probability2 >= 0)  BEGIN WRITE_BYTE  (base + 0x13 + (0x13 * fx_type)) probability2  END END
            PATCH_IF ("%dicenumber_ex%"    STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_LONG  (base + 0x1c + (0x14 * fx_type)) (REPLACE_dicenumber_ex)    END ELSE BEGIN
            PATCH_IF (dicenumber >= 0)    BEGIN WRITE_LONG  (base + 0x1c + (0x14 * fx_type)) dicenumber    END END
            PATCH_IF ("%dicesize_ex%"      STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_LONG  (base + 0x20 + (0x14 * fx_type)) (REPLACE_dicesize_ex)      END ELSE BEGIN
            PATCH_IF (dicesize >= 0)      BEGIN WRITE_LONG  (base + 0x20 + (0x14 * fx_type)) dicesize      END END
            PATCH_IF ("%savingthrow_ex%"   STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_LONG  (base + 0x24 + (0x14 * fx_type)) (REPLACE_savingthrow_ex)   END ELSE BEGIN
            PATCH_IF (savingthrow >= 0)   BEGIN WRITE_LONG  (base + 0x24 + (0x14 * fx_type)) savingthrow   END END
            PATCH_IF ("%savebonus_ex%"     STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_LONG  (base + 0x28 + (0x14 * fx_type)) (REPLACE_savebonus_ex)     END ELSE BEGIN
            PATCH_IF (savebonus >= "-10") BEGIN WRITE_LONG  (base + 0x28 + (0x14 * fx_type)) savebonus     END END
            PATCH_IF ("%special_ex%"       STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_LONG  (base + 0x2c + (0x14 * fx_type)) (REPLACE_special_ex)       END ELSE BEGIN
            PATCH_IF (special >= 0)       BEGIN WRITE_LONG  (base + 0x2c + (0x14 * fx_type)) special       END END

            PATCH_IF ("%resource_ex%" STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_ASCIIE (base + 0x14 + (0x14 * fx_type)) REPLACE_resource_ex #8       END ELSE BEGIN
            PATCH_IF ("%resource%"    STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_ASCIIE (base + 0x14 + (0x14 * fx_type)) "%resource%" #8 END END

            // update the tracking vars
            SET new_fx += 1
            SET counter += 1
            PATCH_IF (local_multi < 2) BEGIN  // kill loop if we only want one match
              SET index2 = counter
            END ELSE BEGIN // otherwise bump vars and keep going
              SET local_multi  -= 1
              PATCH_IF ("%insert%" STRING_COMPARE_CASE "last" = 0) BEGIN
                SET last += 1
              END ELSE BEGIN
                SET index2 += 1
              END
            END

          END // end patch_if for a matched effect
        END // end of the for loop through effects
      END // end patch_if for matched/specified headers

END

>>>>>>>>

    COPY ~./inline/clone_effect_ex_macro.tph~ ~./inline/clone_effect_ex_macro_working.tph~
      REPLACE_TEXTUALLY ~REPLACE_header_type_ex~         ~%header_type_ex%~
      REPLACE_TEXTUALLY ~REPLACE_match_opcode_ex~        ~%match_opcode_ex%~
      REPLACE_TEXTUALLY ~REPLACE_match_target_ex~        ~%match_target_ex%~
      REPLACE_TEXTUALLY ~REPLACE_match_power_ex~         ~%match_power_ex%~
      REPLACE_TEXTUALLY ~REPLACE_match_parameter1_ex~    ~%match_parameter1_ex%~
      REPLACE_TEXTUALLY ~REPLACE_match_parameter2_ex~    ~%match_parameter2_ex%~
      REPLACE_TEXTUALLY ~REPLACE_match_timing_ex~        ~%match_timing_ex%~
      REPLACE_TEXTUALLY ~REPLACE_match_resist_dispel_ex~ ~%match_resist_dispel_ex%~
      REPLACE_TEXTUALLY ~REPLACE_match_duration_ex~      ~%match_duration_ex%~
      REPLACE_TEXTUALLY ~REPLACE_match_probability1_ex~  ~%match_probability1_ex%~
      REPLACE_TEXTUALLY ~REPLACE_match_probability2_ex~  ~%match_probability2_ex%~
      REPLACE_TEXTUALLY ~REPLACE_match_dicenumber_ex~    ~%match_dicenumber_ex%~
      REPLACE_TEXTUALLY ~REPLACE_match_dicesize_ex~      ~%match_dicesize_ex%~
      REPLACE_TEXTUALLY ~REPLACE_match_savingthrow_ex~   ~%match_savingthrow_ex%~
      REPLACE_TEXTUALLY ~REPLACE_match_savebonus_ex~     ~%match_savebonus_ex%~
      REPLACE_TEXTUALLY ~REPLACE_match_special_ex~       ~%match_special_ex%~
      REPLACE_TEXTUALLY ~REPLACE_opcode_ex~              ~%opcode_ex%~
      REPLACE_TEXTUALLY ~REPLACE_target_ex~              ~%target_ex%~
      REPLACE_TEXTUALLY ~REPLACE_power_ex~               ~%power_ex%~
      REPLACE_TEXTUALLY ~REPLACE_parameter1_ex~          ~%parameter1_ex%~
      REPLACE_TEXTUALLY ~REPLACE_parameter2_ex~          ~%parameter2_ex%~
      REPLACE_TEXTUALLY ~REPLACE_timing_ex~              ~%timing_ex%~
      REPLACE_TEXTUALLY ~REPLACE_resist_dispel_ex~       ~%resist_dispel_ex%~
      REPLACE_TEXTUALLY ~REPLACE_duration_ex~            ~%duration_ex%~
      REPLACE_TEXTUALLY ~REPLACE_probability1_ex~        ~%probability1_ex%~
      REPLACE_TEXTUALLY ~REPLACE_probability2_ex~        ~%probability2_ex%~
      REPLACE_TEXTUALLY ~REPLACE_dicenumber_ex~          ~%dicenumber_ex%~
      REPLACE_TEXTUALLY ~REPLACE_dicesize_ex~            ~%dicesize_ex%~
      REPLACE_TEXTUALLY ~REPLACE_savingthrow_ex~         ~%savingthrow_ex%~
      REPLACE_TEXTUALLY ~REPLACE_savebonus_ex~           ~%savebonus_ex%~
      REPLACE_TEXTUALLY ~REPLACE_special_ex~             ~%special_ex%~
      REPLACE_TEXTUALLY ~REPLACE_match_resource_ex~      ~%match_resource_ex%~
      REPLACE_TEXTUALLY ~REPLACE_resource_ex~            ~%resource_ex%~

      REINCLUDE ~./inline/clone_effect_ex_macro_working.tph~

  END // end INNER_ACTION

  SPRINT SOURCE_FILE ~%o_SOURCE_FILE%~ // reset copy vars
  SPRINT SOURCE_RES  ~%o_SOURCE_RES%~
  SPRINT DEST_FILE   ~%o_DEST_FILE%~
  SPRINT DEST_RES    ~%o_DEST_RES%~

  PATCH_IF (BUFFER_LENGTH >= min_size) BEGIN // sanity check
    FOR (index = (0 - check_globals) ; index < abil_num ; ++index) BEGIN // we start at -1 for global effects
      PATCH_IF (index < 0) BEGIN // if loop through globals needed
        SET abil_fx_idx = 0  // start with effect 0 since we're in the global loop
        SET abil_type = "-1" // basically, ignore header type checks for global loop
      END ELSE BEGIN // otherwise normal ability
        READ_BYTE   (abil_off +        (abil_length * index)) abil_type
        SET counter_offset = (abil_off + 0x1e + (abil_length * index))
        WRITE_SHORT (abil_off + 0x20 + (abil_length * index)) (THIS + new_fx) // update index with previously added effects
        READ_SHORT  (abil_off + 0x20 + (abil_length * index)) abil_fx_idx
      END
      READ_SHORT counter_offset counter // fx_num on global loop, otherwise abil_fx_num
      LAUNCH_PATCH_MACRO clone_effect_ex_macro_working
      WRITE_SHORT counter_offset counter // fx_num on global loop, otherwise abil_fx_num
    END // end loop through effects on ability
  END // end ability loop

  // now adjust offsets for creature files
  PATCH_IF (("%sig%" STRING_EQUAL "CRE ") AND (new_fx > 0)) BEGIN // fix offsets for cre files if fx inserted
    SET inserted = ((0x30 + (0xd8 * fx_type)) * new_fx)
    PATCH_IF ("%version%" STRING_COMPARE_CASE "V1.2" = 0) BEGIN // pst, cre v1.2
      PATCH_FOR_EACH offset IN 0x294 0x344 0x34c 0x354 0x35c 0x360 BEGIN
        READ_LONG offset off
        PATCH_IF (fx_off < off) BEGIN
          WRITE_LONG offset (off + inserted)
        END
      END
    END ELSE
    PATCH_IF ("%version%" STRING_COMPARE_CASE "V2.2" = 0) BEGIN // iwd2, cre v2.2
      PATCH_FOR_EACH offset IN 0x5fa 0x602 0x60a 0x612 0x616 BEGIN
        READ_LONG offset off
        PATCH_IF (fx_off < off) BEGIN
          WRITE_LONG offset (off + inserted)
        END
      END
      FOR (offset = 0x3ba ; offset < 0x4b3 ; offset = offset + 0x04) BEGIN // all of the spell offsets
        READ_LONG offset off
        PATCH_IF (fx_off < off) BEGIN
          WRITE_LONG offset (off + inserted)
        END
      END
      FOR (offset = 0x5b2 ; offset < 0x5d3 ; offset = offset + 0x04) BEGIN // domain spell offsets
        READ_LONG offset off
        PATCH_IF (fx_off < off) BEGIN
          WRITE_LONG offset (off + inserted)
        END
      END
    END ELSE
    PATCH_IF ("%version%" STRING_COMPARE_CASE "V9.0" = 0) BEGIN // iwd, cre v9.0
      PATCH_FOR_EACH offset IN 0x308 0x310 0x318 0x320 0x324 BEGIN
        READ_LONG offset off
        PATCH_IF (fx_off < off) BEGIN
          WRITE_LONG offset (off + inserted)
        END
      END
    END ELSE BEGIN                                               // everything else, cre v1.0
      PATCH_FOR_EACH offset IN 0x2a0 0x2a8 0x2b0 0x2b8 0x2bc BEGIN
        READ_LONG offset off
        PATCH_IF (fx_off < off) BEGIN
          WRITE_LONG offset (off + inserted)
        END
      END
    END
  END

  PATCH_IF (new_fx = 0 && !silent) BEGIN
    PATCH_WARN "WARNING: no effects added to %SOURCE_FILE% via CLONE_EFFECT_FX"
  END ELSE PATCH_IF (verbose && !silent) BEGIN
    READ_LONG 0x0c strref
    PATCH_IF ((strref > 0) AND (strref < 200000)) BEGIN
      READ_STRREF 0x0c name
    END ELSE BEGIN
      READ_STRREF 0x08 name
    END
    PATCH_PRINT "              ~%SOURCE_FILE%~   ~override~ // %name%, %new_fx% effect(s) added via CLONE_EFFECT_FX"
  END

END

/////                                                  \\\\\
///// DELETE_EFFECT_EX                                 \\\\\
/////                                                  \\\\\

DEFINE_PATCH_FUNCTION DELETE_EFFECT_EX

  // defines what we're going to check
  INT_VAR check_globals       = 1
          check_headers       = 1
          header              = "-1"
          header_type         = "-1"
          multi_match         = 999
          verbose             = 0

  // variables for finding the effect to match
          match_opcode        = "-1"
          match_target        = "-1"
          match_power         = "-1"
          match_parameter1    = "-1"
          match_parameter2    = "-1"
          match_timing        = "-1"
          match_resist_dispel = "-1"
          match_duration      = "-1"
          match_duration_high = "-1"
          match_probability1  = "-1"
          match_probability2  = "-1"
          match_dicenumber    = "-1"
          match_dicesize      = "-1"
          match_savingthrow   = "-1"
          match_savebonus     = "-11"
          match_special       = "-1"

  // same for match and new STR_VAR
  STR_VAR match_resource      = "SAME"

  // defines what we're going to check
          header_type_ex         = ~((header = index) OR (header < 0))~

  // string variables for finding the effect to match
          match_opcode_ex        = ~((match_opcode        = o_opcode)        OR (match_opcode < 0))~
          match_target_ex        = ~((match_target        = o_target)        OR (match_target < 0))~
          match_power_ex         = ~((match_power         = o_power)         OR (match_power < 0))~
          match_parameter1_ex    = ~((match_parameter1    = o_parameter1)    OR (match_parameter1 < 0))~
          match_parameter2_ex    = ~((match_parameter2    = o_parameter2)    OR (match_parameter2 < 0))~
          match_timing_ex        = ~((match_timing        = o_timing)        OR (match_timing < 0))~
          match_resist_dispel_ex = ~((match_resist_dispel = o_resist_dispel) OR (match_resist_dispel < 0))~
          match_duration_ex      = ~((match_duration      = o_duration)      OR (match_duration < 0))~
          match_probability1_ex  = ~((match_probability1  = o_probability1)  OR (match_probability1 < 0))~
          match_probability2_ex  = ~((match_probability2  = o_probability2)  OR (match_probability2 < 0))~
          match_dicenumber_ex    = ~((match_dicenumber    = o_dicenumber)    OR (match_dicenumber < 0))~
          match_dicesize_ex      = ~((match_dicesize      = o_dicesize)      OR (match_dicesize < 0))~
          match_savingthrow_ex   = ~((match_savingthrow   = o_savingthrow)   OR (match_savingthrow < 0))~
          match_savebonus_ex     = ~((match_savebonus     = o_savebonus)     OR (match_savebonus < "-10"))~
          match_special_ex       = ~((match_special       = o_special)       OR (match_special < 0))~
          match_resource_ex      = ~(("%match_resource%" STRING_COMPARE_CASE "%o_resource%" = 0) OR ("%match_resource%" STRING_COMPARE_CASE "SAME" = 0))~

BEGIN

  // set variables and offsets based on the file type
  SET new_fx = 0
  READ_ASCII 0 sig ELSE "fail" (4)
  READ_ASCII 0x04 version (4)
  PATCH_MATCH "%sig%" WITH
    "SPL "
    BEGIN
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V2.0" = 0) BEGIN // iwd2, spl 2.0
        SET min_size       = 0x82
      END ELSE BEGIN
        SET min_size       = 0x72
      END
      READ_LONG   0x6a fx_off   ELSE 0
      SET counter_offset = 0x70
      SET abil_length    = 0x28
      SET fx_type        = 0
      READ_LONG   0x64 abil_off ELSE 0
      READ_SHORT  0x68 abil_num ELSE 0
    END

    "ITM "
    BEGIN
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V1.1" = 0) BEGIN // pst, itm v1.1
        SET min_size       = 0x9a
      END ELSE BEGIN
        SET min_size       = 0x72
      END
      READ_LONG   0x6a fx_off   ELSE 0
      SET counter_offset = 0x70
      SET abil_length    = 0x38
      SET fx_type        = 0
      READ_LONG   0x64 abil_off ELSE 0
      READ_SHORT  0x68 abil_num ELSE 0
    END

    "CRE "
    BEGIN
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V1.2" = 0) BEGIN // pst, cre v1.2
        SET min_size       = 0x378
        READ_LONG  0x368 fx_off
        SET counter_offset = 0x36c
      END ELSE
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V2.2" = 0) BEGIN // iwd2, cre v2.2
        SET min_size       = 0x62e
        READ_LONG  0x61e fx_off
        SET counter_offset = 0x622
      END ELSE
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V9.0" = 0) BEGIN // iwd, cre v9.0
        SET min_size       = 0x33c
        READ_LONG  0x32c fx_off
        SET counter_offset = 0x330
      END ELSE BEGIN                                               // everything else, cre v1.0
        SET min_size = 0x2d4
        READ_LONG  0x2c4 fx_off
        SET counter_offset = 0x2c8
      END
      SET abil_off = 0 // basically prevents the ability effect loop
      SET abil_num = 0
      SET abil_length = 0
      SET check_globals = 1
      READ_BYTE 0x33 fx_type ELSE 2
    END

    "fail"
    BEGIN
      PATCH_WARN "WARNING: DELETE_EFFECT_EX does not think %SOURCE_FILE% appears to be a valid file"
    END

    DEFAULT
      SET min_size = "-1" // kill macro as the file type is not recognized
      PATCH_WARN "WARNING: DELETE_EFFECT_EX does not support file type %sig%"
  END

  SPRINT o_SOURCE_FILE ~%SOURCE_FILE%~ // preserve original copy vars
  SPRINT o_SOURCE_RES  ~%SOURCE_RES%~
  SPRINT o_DEST_FILE   ~%DEST_FILE%~
  SPRINT o_DEST_RES    ~%DEST_RES%~
  INNER_ACTION BEGIN

<<<<<<<<./inline/delete_effect_ex_macro.tph

DEFINE_PATCH_MACRO delete_effect_ex_macro_working BEGIN

      PATCH_IF (((abil_type = header_type) OR (abil_type < 0) OR (header_type < 0)) AND // only look on the right header types, if specified...
                (REPLACE_header_type_ex) AND                                  // and only on the right # header, if specified
                ((index < 0) OR (check_headers))) BEGIN                                 // if check headers = 0, only re-index
        SET local_multi = multi_match
        FOR (index2 = 0 ; index2 < counter ; ++index2) BEGIN

          // read the variables from the current effect
          READ_SHORT (fx_off        + (0x08 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_opcode
          READ_BYTE  (fx_off + 0x02 + (0x0a * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_target
          READ_BYTE  (fx_off + 0x03 + (0x0d * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_power
          READ_LONG  (fx_off + 0x04 + (0x10 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_parameter1
          READ_LONG  (fx_off + 0x08 + (0x10 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_parameter2
          READ_BYTE  (fx_off + 0x0c + (0x10 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_timing
          READ_BYTE  (fx_off + 0x0d + (0x47 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_resist_dispel
          READ_LONG  (fx_off + 0x0e + (0x12 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_duration
          READ_BYTE  (fx_off + 0x12 + (0x12 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_probability1
          READ_BYTE  (fx_off + 0x13 + (0x13 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_probability2
          READ_ASCII (fx_off + 0x14 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_resource
          READ_LONG  (fx_off + 0x1c + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_dicenumber
          READ_LONG  (fx_off + 0x20 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_dicesize
          READ_LONG  (fx_off + 0x24 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_savingthrow
          READ_LONG  (fx_off + 0x28 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_savebonus
          READ_LONG  (fx_off + 0x2c + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_special

          // match ALL these variables, if specified
          PATCH_IF ((REPLACE_match_opcode_ex)        AND
                    (REPLACE_match_target_ex)        AND
                    (REPLACE_match_power_ex)         AND
                    (REPLACE_match_parameter1_ex)    AND
                    (REPLACE_match_parameter2_ex)    AND
                    (REPLACE_match_timing_ex)        AND
                    (REPLACE_match_resist_dispel_ex) AND
                    (REPLACE_match_duration_ex)      AND
                    (REPLACE_match_probability1_ex)  AND
                    (REPLACE_match_probability2_ex)  AND
                    (REPLACE_match_dicenumber_ex)    AND
                    (REPLACE_match_dicesize_ex)      AND
                    (REPLACE_match_savingthrow_ex)   AND
                    (REPLACE_match_savebonus_ex)     AND
                    (REPLACE_match_special_ex)       AND
                    (REPLACE_match_resource_ex))
          BEGIN

            // now that we've got a match, read-and-clone it:
            DELETE_BYTES   (fx_off        + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) (0x30 + (0xd8 * fx_type))

            // update the tracking vars
            SET new_fx -= 1
            SET counter -= 1
            SET index2 -= 1
            PATCH_IF (local_multi < 2) BEGIN  // kill loop if we only want one match
              SET index2 = counter
            END ELSE BEGIN // otherwise bump vars and keep going
              SET local_multi  -= 1
            END

          END // end patch_if for a matched effect
        END // end of the for loop through effects
      END // end patch_if for matched/specified headers

END

>>>>>>>>

    COPY ~./inline/delete_effect_ex_macro.tph~ ~./inline/delete_effect_ex_macro_working.tph~
      REPLACE_TEXTUALLY ~REPLACE_header_type_ex~         ~%header_type_ex%~
      REPLACE_TEXTUALLY ~REPLACE_match_opcode_ex~        ~%match_opcode_ex%~
      REPLACE_TEXTUALLY ~REPLACE_match_target_ex~        ~%match_target_ex%~
      REPLACE_TEXTUALLY ~REPLACE_match_power_ex~         ~%match_power_ex%~
      REPLACE_TEXTUALLY ~REPLACE_match_parameter1_ex~    ~%match_parameter1_ex%~
      REPLACE_TEXTUALLY ~REPLACE_match_parameter2_ex~    ~%match_parameter2_ex%~
      REPLACE_TEXTUALLY ~REPLACE_match_timing_ex~        ~%match_timing_ex%~
      REPLACE_TEXTUALLY ~REPLACE_match_resist_dispel_ex~ ~%match_resist_dispel_ex%~
      REPLACE_TEXTUALLY ~REPLACE_match_duration_ex~      ~%match_duration_ex%~
      REPLACE_TEXTUALLY ~REPLACE_match_probability1_ex~  ~%match_probability1_ex%~
      REPLACE_TEXTUALLY ~REPLACE_match_probability2_ex~  ~%match_probability2_ex%~
      REPLACE_TEXTUALLY ~REPLACE_match_dicenumber_ex~    ~%match_dicenumber_ex%~
      REPLACE_TEXTUALLY ~REPLACE_match_dicesize_ex~      ~%match_dicesize_ex%~
      REPLACE_TEXTUALLY ~REPLACE_match_savingthrow_ex~   ~%match_savingthrow_ex%~
      REPLACE_TEXTUALLY ~REPLACE_match_savebonus_ex~     ~%match_savebonus_ex%~
      REPLACE_TEXTUALLY ~REPLACE_match_special_ex~       ~%match_special_ex%~
      REPLACE_TEXTUALLY ~REPLACE_match_resource_ex~      ~%match_resource_ex%~

      REINCLUDE ~./inline/delete_effect_ex_macro_working.tph~

  END // end INNER_ACTION

  SPRINT SOURCE_FILE ~%o_SOURCE_FILE%~ // reset copy vars
  SPRINT SOURCE_RES  ~%o_SOURCE_RES%~
  SPRINT DEST_FILE   ~%o_DEST_FILE%~
  SPRINT DEST_RES    ~%o_DEST_RES%~

  PATCH_IF (BUFFER_LENGTH >= min_size) BEGIN // sanity check
    FOR (index = (0 - check_globals) ; index < abil_num ; ++index) BEGIN // we start at -1 for global effects
      PATCH_IF (index < 0) BEGIN // if loop through globals needed
        SET abil_fx_idx = 0  // start with effect 0 since we're in the global loop
        SET abil_type = "-1" // basically, ignore header type checks for global loop
      END ELSE BEGIN // otherwise normal ability
        READ_BYTE   (abil_off +        (abil_length * index)) abil_type
        SET counter_offset = (abil_off + 0x1e + (abil_length * index))
        WRITE_SHORT (abil_off + 0x20 + (abil_length * index)) (THIS + new_fx) // update index with previously added effects
        READ_SHORT  (abil_off + 0x20 + (abil_length * index)) abil_fx_idx
      END
      READ_SHORT counter_offset counter // fx_num on global loop, otherwise abil_fx_num
      LAUNCH_PATCH_MACRO delete_effect_ex_macro_working
      WRITE_SHORT counter_offset counter // fx_num on global loop, otherwise abil_fx_num
    END // end loop through effects on ability
  END // end ability loop

  // now adjust offsets for creature files
  PATCH_IF (("%sig%" STRING_EQUAL "CRE ") AND (new_fx != 0)) BEGIN // fix offsets for cre files if #fx changed
    SET inserted = ((0x30 + (0xd8 * fx_type)) * new_fx)
    PATCH_IF ("%version%" STRING_COMPARE_CASE "V1.2" = 0) BEGIN // pst, cre v1.2
      PATCH_FOR_EACH offset IN 0x294 0x344 0x34c 0x354 0x35c 0x360 BEGIN
        READ_LONG offset off
        PATCH_IF (fx_off < off) BEGIN
          WRITE_LONG offset (off + inserted)
        END
      END
    END ELSE
    PATCH_IF ("%version%" STRING_COMPARE_CASE "V2.2" = 0) BEGIN // iwd2, cre v2.2
      PATCH_FOR_EACH offset IN 0x5fa 0x602 0x60a 0x612 0x616 BEGIN
        READ_LONG offset off
        PATCH_IF (fx_off < off) BEGIN
          WRITE_LONG offset (off + inserted)
        END
      END
      FOR (offset = 0x3ba ; offset < 0x4b3 ; offset = offset + 0x04) BEGIN // all of the spell offsets
        READ_LONG offset off
        PATCH_IF (fx_off < off) BEGIN
          WRITE_LONG offset (off + inserted)
        END
      END
      FOR (offset = 0x5b2 ; offset < 0x5d3 ; offset = offset + 0x04) BEGIN // domain spell offsets
        READ_LONG offset off
        PATCH_IF (fx_off < off) BEGIN
          WRITE_LONG offset (off + inserted)
        END
      END
    END ELSE
    PATCH_IF ("%version%" STRING_COMPARE_CASE "V9.0" = 0) BEGIN // iwd, cre v9.0
      PATCH_FOR_EACH offset IN 0x308 0x310 0x318 0x320 0x324 BEGIN
        READ_LONG offset off
        PATCH_IF (fx_off < off) BEGIN
          WRITE_LONG offset (off + inserted)
        END
      END
    END ELSE BEGIN                                               // everything else, cre v1.0
      PATCH_FOR_EACH offset IN 0x2a0 0x2a8 0x2b0 0x2b8 0x2bc BEGIN
        READ_LONG offset off
        PATCH_IF (fx_off < off) BEGIN
          WRITE_LONG offset (off + inserted)
        END
      END
    END
  END

  PATCH_IF (verbose) BEGIN
    READ_LONG 0x0c strref
    PATCH_IF ((strref > 0) AND (strref < 200000)) BEGIN
      READ_STRREF 0x0c name
    END ELSE BEGIN
      READ_STRREF 0x08 name
    END
    PATCH_PRINT "              ~%SOURCE_FILE%~   ~override~ // %name%, %new_fx% effect(s) deleted via DELETE_EFFECT_EX"
  END

END

/////                                                  \\\\\
///// ALTER_EFFECT_EX                                  \\\\\
/////                                                  \\\\\

DEFINE_PATCH_FUNCTION ALTER_EFFECT_EX

  // defines what we're going to check
  INT_VAR check_globals       = 1
          check_headers       = 1
          header              = "-1"
          header_type         = "-1"
          multi_match         = 999
          verbose             = 0
          silent              = 0

  // variables for finding the effect to match
          match_opcode        = "-1"
          match_target        = "-1"
          match_power         = "-1"
          match_parameter1    = "-1"
          match_parameter2    = "-1"
          match_timing        = "-1"
          match_resist_dispel = "-1"
          match_duration      = "-1"
          match_duration_high = "-1"
          match_probability1  = "-1"
          match_probability2  = "-1"
          match_dicenumber    = "-1"
          match_dicesize      = "-1"
          match_savingthrow   = "-1"
          match_savebonus     = "-11"
          match_special       = "-1"

  // variables for the new effect
          opcode              = "-1"
          target              = "-1"
          power               = "-1"
          parameter1          = "-1"
          parameter2          = "-1"
          timing              = "-1"
          resist_dispel       = "-1"
          duration            = "-1"
          duration_high       = "-1"
          probability1        = "-1"
          probability2        = "-1"
          dicenumber          = "-1"
          dicesize            = "-1"
          savingthrow         = "-1"
          savebonus           = "-11"
          special             = "-1"

  // same for match and new STR_VAR
  STR_VAR match_resource      = "SAME"
          resource            = "SAME"

  // defines what we're going to check
          header_type_ex         = ~((header = index) OR (header < 0))~

  // string variables for finding the effect to match
          match_opcode_ex        = ~((match_opcode        = o_opcode)        OR (match_opcode < 0))~
          match_target_ex        = ~((match_target        = o_target)        OR (match_target < 0))~
          match_power_ex         = ~((match_power         = o_power)         OR (match_power < 0))~
          match_parameter1_ex    = ~((match_parameter1    = o_parameter1)    OR (match_parameter1 < 0))~
          match_parameter2_ex    = ~((match_parameter2    = o_parameter2)    OR (match_parameter2 < 0))~
          match_timing_ex        = ~((match_timing        = o_timing)        OR (match_timing < 0))~
          match_resist_dispel_ex = ~((match_resist_dispel = o_resist_dispel) OR (match_resist_dispel < 0))~
          match_duration_ex      = ~((match_duration      = o_duration)      OR (match_duration < 0))~
          match_probability1_ex  = ~((match_probability1  = o_probability1)  OR (match_probability1 < 0))~
          match_probability2_ex  = ~((match_probability2  = o_probability2)  OR (match_probability2 < 0))~
          match_dicenumber_ex    = ~((match_dicenumber    = o_dicenumber)    OR (match_dicenumber < 0))~
          match_dicesize_ex      = ~((match_dicesize      = o_dicesize)      OR (match_dicesize < 0))~
          match_savingthrow_ex   = ~((match_savingthrow   = o_savingthrow)   OR (match_savingthrow < 0))~
          match_savebonus_ex     = ~((match_savebonus     = o_savebonus)     OR (match_savebonus < "-10"))~
          match_special_ex       = ~((match_special       = o_special)       OR (match_special < 0))~
          match_resource_ex      = ~(("%match_resource%" STRING_COMPARE_CASE "%o_resource%" = 0) OR ("%match_resource%" STRING_COMPARE_CASE "SAME" = 0))~

  // stringvariables for the new effect
          opcode_ex              = "SAME"
          target_ex              = "SAME"
          power_ex               = "SAME"
          parameter1_ex          = "SAME"
          parameter2_ex          = "SAME"
          timing_ex              = "SAME"
          resist_dispel_ex       = "SAME"
          duration_ex            = "SAME"
          probability1_ex        = "SAME"
          probability2_ex        = "SAME"
          dicenumber_ex          = "SAME"
          dicesize_ex            = "SAME"
          savingthrow_ex         = "SAME"
          savebonus_ex           = "SAME"
          special_ex             = "SAME"
          resource_ex            = "SAME"

BEGIN

  // set variables and offsets based on the file type
  SET alter = 0
  READ_ASCII 0 sig ELSE "fail" (4)
  READ_ASCII 0x04 version (4)
  PATCH_MATCH "%sig%" WITH
    "SPL "
    BEGIN
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V2.0" = 0) BEGIN // iwd2, spl 2.0
        SET min_size       = 0x82
      END ELSE BEGIN
        SET min_size       = 0x72
      END
      READ_LONG   0x6a fx_off   ELSE 0
      SET counter_offset = 0x70
      SET abil_length    = 0x28
      SET fx_type        = 0
      PATCH_IF (check_headers = 0) BEGIN
        SET abil_num = 0
      END ELSE BEGIN
        READ_LONG   0x64 abil_off ELSE 0
        READ_SHORT  0x68 abil_num ELSE 0
      END
    END

    "ITM "
    BEGIN
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V1.1" = 0) BEGIN // pst, itm v1.1
        SET min_size       = 0x9a
      END ELSE BEGIN
        SET min_size       = 0x72
      END
      READ_LONG   0x6a fx_off   ELSE 0
      SET counter_offset = 0x70
      SET abil_length    = 0x38
      SET fx_type        = 0
      PATCH_IF (check_headers = 0) BEGIN
        SET abil_num = 0
      END ELSE BEGIN
        READ_LONG   0x64 abil_off ELSE 0
        READ_SHORT  0x68 abil_num ELSE 0
      END
    END

    "CRE "
    BEGIN
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V1.2" = 0) BEGIN // pst, cre v1.2
        SET min_size       = 0x378
        READ_LONG  0x368 fx_off ELSE 0
        SET counter_offset = 0x36c
      END ELSE
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V2.2" = 0) BEGIN // iwd2, cre v2.2
        SET min_size       = 0x62e
        READ_LONG  0x61e fx_off ELSE 0
        SET counter_offset = 0x622
      END ELSE
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V9.0" = 0) BEGIN // iwd, cre v9.0
        SET min_size       = 0x33c
        READ_LONG  0x32c fx_off ELSE 0
        SET counter_offset = 0x330
      END ELSE BEGIN                                               // everything else, cre v1.0
        SET min_size = 0x2d4
        READ_LONG  0x2c4 fx_off ELSE 0
        SET counter_offset = 0x2c8
      END
      SET abil_off = 0 // basically prevents the ability effect loop
      SET abil_num = 0
      SET abil_length = 0
      SET check_globals = 1
      READ_BYTE 0x33 fx_type ELSE 2
    END

    "fail"
    BEGIN
      PATCH_WARN "WARNING: ALTER_EFFECT_EX does not think %SOURCE_FILE% appears to be a valid file"
    END

    DEFAULT
      SET min_size = "-1" // kill macro as the file type is not recognized
      PATCH_WARN "WARNING: ALTER_EFFECT_EX does not support file type %sig%"
  END

  SPRINT o_SOURCE_FILE ~%SOURCE_FILE%~ // preserve original copy vars
  SPRINT o_SOURCE_RES  ~%SOURCE_RES%~
  SPRINT o_DEST_FILE   ~%DEST_FILE%~
  SPRINT o_DEST_RES    ~%DEST_RES%~
  INNER_ACTION BEGIN

<<<<<<<<./inline/alter_effect_ex_macro.tph

DEFINE_PATCH_MACRO alter_effect_ex_macro_working BEGIN

      PATCH_IF (((abil_type = header_type) OR (abil_type < 0) OR (header_type < 0)) AND // only look on the right header types, if specified...
                ((header = index) OR (header < 0))) BEGIN                               // and only on the right # header, if specified
        SET local_multi = multi_match
        FOR (index2 = 0 ; index2 < counter ; ++index2) BEGIN

          // read the variables from the current effect
          READ_SHORT (fx_off        + (0x08 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_opcode
          READ_BYTE  (fx_off + 0x02 + (0x0a * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_target
          READ_BYTE  (fx_off + 0x03 + (0x0d * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_power
          READ_LONG  (fx_off + 0x04 + (0x10 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_parameter1
          READ_LONG  (fx_off + 0x08 + (0x10 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_parameter2
          READ_BYTE  (fx_off + 0x0c + (0x10 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_timing
          READ_BYTE  (fx_off + 0x0d + (0x47 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_resist_dispel
          READ_LONG  (fx_off + 0x0e + (0x12 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_duration
          READ_BYTE  (fx_off + 0x12 + (0x12 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_probability1
          READ_BYTE  (fx_off + 0x13 + (0x13 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_probability2
          READ_ASCII (fx_off + 0x14 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_resource
          READ_LONG  (fx_off + 0x1c + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_dicenumber
          READ_LONG  (fx_off + 0x20 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_dicesize
          READ_LONG  (fx_off + 0x24 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_savingthrow
          READ_LONG  (fx_off + 0x28 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_savebonus
          READ_LONG  (fx_off + 0x2c + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_special

          // match ALL these variables, if specified
          PATCH_IF ((REPLACE_match_opcode_ex)        AND
                    (REPLACE_match_target_ex)        AND
                    (REPLACE_match_power_ex)         AND
                    (REPLACE_match_parameter1_ex)    AND
                    (REPLACE_match_parameter2_ex)    AND
                    (REPLACE_match_timing_ex)        AND
                    (REPLACE_match_resist_dispel_ex) AND
                    (REPLACE_match_duration_ex)      AND
                    (REPLACE_match_probability1_ex)  AND
                    (REPLACE_match_probability2_ex)  AND
                    (REPLACE_match_dicenumber_ex)    AND
                    (REPLACE_match_dicesize_ex)      AND
                    (REPLACE_match_savingthrow_ex)   AND
                    (REPLACE_match_savebonus_ex)     AND
                    (REPLACE_match_special_ex)       AND
                    (REPLACE_match_resource_ex))
          BEGIN

            // lazily re-use code
            SET base = (fx_off        + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type))))

            // overwrite the cloned effect with the new variables, if specified
            PATCH_IF ("%opcode_ex%"        STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_SHORT (base        + (0x08 * fx_type)) (REPLACE_opcode_ex)        END ELSE BEGIN
            PATCH_IF (opcode >= 0)        BEGIN WRITE_SHORT (base        + (0x08 * fx_type)) opcode        END END
            PATCH_IF ("%target_ex%"        STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_BYTE  (base + 0x02 + (0x0a * fx_type)) (REPLACE_target_ex)        END ELSE BEGIN
            PATCH_IF (target >= 0)        BEGIN WRITE_BYTE  (base + 0x02 + (0x0a * fx_type)) target        END END
            PATCH_IF ("%power_ex%"         STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_BYTE  (base + 0x03 + (0x0d * fx_type)) (REPLACE_power_ex)         END ELSE BEGIN
            PATCH_IF (power >= 0)         BEGIN WRITE_BYTE  (base + 0x03 + (0x0d * fx_type)) power         END END
            PATCH_IF ("%parameter1_ex%"    STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_LONG  (base + 0x04 + (0x10 * fx_type)) (REPLACE_parameter1_ex)    END ELSE BEGIN
            PATCH_IF (parameter1 >= 0)    BEGIN WRITE_LONG  (base + 0x04 + (0x10 * fx_type)) parameter1    END END
            PATCH_IF ("%parameter2_ex%"    STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_LONG  (base + 0x08 + (0x10 * fx_type)) (REPLACE_parameter2_ex)    END ELSE BEGIN
            PATCH_IF (parameter2 >= 0)    BEGIN WRITE_LONG  (base + 0x08 + (0x10 * fx_type)) parameter2    END END
            PATCH_IF ("%timing_ex%"        STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_BYTE  (base + 0x0c + (0x10 * fx_type)) (REPLACE_timing_ex)        END ELSE BEGIN
            PATCH_IF (timing >= 0)        BEGIN WRITE_BYTE  (base + 0x0c + (0x10 * fx_type)) timing        END END
            PATCH_IF ("%resist_dispel_ex%" STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_BYTE  (base + 0x0d + (0x47 * fx_type)) (REPLACE_resist_dispel_ex) END ELSE BEGIN
            PATCH_IF (resist_dispel >= 0) BEGIN WRITE_BYTE  (base + 0x0d + (0x47 * fx_type)) resist_dispel END END
            PATCH_IF ("%duration_ex%"      STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_LONG  (base + 0x0e + (0x12 * fx_type)) (REPLACE_duration_ex)      END ELSE BEGIN
            PATCH_IF (duration >= 0)      BEGIN WRITE_LONG  (base + 0x0e + (0x12 * fx_type)) duration      END END
            PATCH_IF ("%probability1_ex%"  STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_BYTE  (base + 0x12 + (0x12 * fx_type)) (REPLACE_probability1_ex)  END ELSE BEGIN
            PATCH_IF (probability1 >= 0)  BEGIN WRITE_BYTE  (base + 0x12 + (0x12 * fx_type)) probability1  END END
            PATCH_IF ("%probability2_ex%"  STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_BYTE  (base + 0x13 + (0x13 * fx_type)) (REPLACE_probability2_ex)  END ELSE BEGIN
            PATCH_IF (probability2 >= 0)  BEGIN WRITE_BYTE  (base + 0x13 + (0x13 * fx_type)) probability2  END END
            PATCH_IF ("%dicenumber_ex%"    STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_LONG  (base + 0x1c + (0x14 * fx_type)) (REPLACE_dicenumber_ex)    END ELSE BEGIN
            PATCH_IF (dicenumber >= 0)    BEGIN WRITE_LONG  (base + 0x1c + (0x14 * fx_type)) dicenumber    END END
            PATCH_IF ("%dicesize_ex%"      STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_LONG  (base + 0x20 + (0x14 * fx_type)) (REPLACE_dicesize_ex)      END ELSE BEGIN
            PATCH_IF (dicesize >= 0)      BEGIN WRITE_LONG  (base + 0x20 + (0x14 * fx_type)) dicesize      END END
            PATCH_IF ("%savingthrow_ex%"   STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_LONG  (base + 0x24 + (0x14 * fx_type)) (REPLACE_savingthrow_ex)   END ELSE BEGIN
            PATCH_IF (savingthrow >= 0)   BEGIN WRITE_LONG  (base + 0x24 + (0x14 * fx_type)) savingthrow   END END
            PATCH_IF ("%savebonus_ex%"     STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_LONG  (base + 0x28 + (0x14 * fx_type)) (REPLACE_savebonus_ex)     END ELSE BEGIN
            PATCH_IF (savebonus >= "-10") BEGIN WRITE_LONG  (base + 0x28 + (0x14 * fx_type)) savebonus     END END
            PATCH_IF ("%special_ex%"       STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_LONG  (base + 0x2c + (0x14 * fx_type)) (REPLACE_special_ex)       END ELSE BEGIN
            PATCH_IF (special >= 0)       BEGIN WRITE_LONG  (base + 0x2c + (0x14 * fx_type)) special       END END

            PATCH_IF ("%resource_ex%" STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_ASCIIE (base + 0x14 + (0x14 * fx_type)) REPLACE_resource_ex #8       END ELSE BEGIN
            PATCH_IF ("%resource%"    STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_ASCIIE (base + 0x14 + (0x14 * fx_type)) "%resource%" #8 END END

            // update the tracking vars
            SET alter += 1
            PATCH_IF (local_multi < 2) BEGIN  // kill loop if we only want one match
              SET index2 = counter
            END ELSE BEGIN // otherwise bump vars and keep going
              SET local_multi  -= 1
            END

          END // end patch_if for a matched effect
        END // end of the for loop through effects
      END // end patch_if for matched/specified headers

END

>>>>>>>>

    COPY ~./inline/alter_effect_ex_macro.tph~ ~./inline/alter_effect_ex_macro_working.tph~
      REPLACE_TEXTUALLY ~REPLACE_header_type_ex~         ~%header_type_ex%~
      REPLACE_TEXTUALLY ~REPLACE_match_opcode_ex~        ~%match_opcode_ex%~
      REPLACE_TEXTUALLY ~REPLACE_match_target_ex~        ~%match_target_ex%~
      REPLACE_TEXTUALLY ~REPLACE_match_power_ex~         ~%match_power_ex%~
      REPLACE_TEXTUALLY ~REPLACE_match_parameter1_ex~    ~%match_parameter1_ex%~
      REPLACE_TEXTUALLY ~REPLACE_match_parameter2_ex~    ~%match_parameter2_ex%~
      REPLACE_TEXTUALLY ~REPLACE_match_timing_ex~        ~%match_timing_ex%~
      REPLACE_TEXTUALLY ~REPLACE_match_resist_dispel_ex~ ~%match_resist_dispel_ex%~
      REPLACE_TEXTUALLY ~REPLACE_match_duration_ex~      ~%match_duration_ex%~
      REPLACE_TEXTUALLY ~REPLACE_match_probability1_ex~  ~%match_probability1_ex%~
      REPLACE_TEXTUALLY ~REPLACE_match_probability2_ex~  ~%match_probability2_ex%~
      REPLACE_TEXTUALLY ~REPLACE_match_dicenumber_ex~    ~%match_dicenumber_ex%~
      REPLACE_TEXTUALLY ~REPLACE_match_dicesize_ex~      ~%match_dicesize_ex%~
      REPLACE_TEXTUALLY ~REPLACE_match_savingthrow_ex~   ~%match_savingthrow_ex%~
      REPLACE_TEXTUALLY ~REPLACE_match_savebonus_ex~     ~%match_savebonus_ex%~
      REPLACE_TEXTUALLY ~REPLACE_match_special_ex~       ~%match_special_ex%~
      REPLACE_TEXTUALLY ~REPLACE_opcode_ex~              ~%opcode_ex%~
      REPLACE_TEXTUALLY ~REPLACE_target_ex~              ~%target_ex%~
      REPLACE_TEXTUALLY ~REPLACE_power_ex~               ~%power_ex%~
      REPLACE_TEXTUALLY ~REPLACE_parameter1_ex~          ~%parameter1_ex%~
      REPLACE_TEXTUALLY ~REPLACE_parameter2_ex~          ~%parameter2_ex%~
      REPLACE_TEXTUALLY ~REPLACE_timing_ex~              ~%timing_ex%~
      REPLACE_TEXTUALLY ~REPLACE_resist_dispel_ex~       ~%resist_dispel_ex%~
      REPLACE_TEXTUALLY ~REPLACE_duration_ex~            ~%duration_ex%~
      REPLACE_TEXTUALLY ~REPLACE_probability1_ex~        ~%probability1_ex%~
      REPLACE_TEXTUALLY ~REPLACE_probability2_ex~        ~%probability2_ex%~
      REPLACE_TEXTUALLY ~REPLACE_dicenumber_ex~          ~%dicenumber_ex%~
      REPLACE_TEXTUALLY ~REPLACE_dicesize_ex~            ~%dicesize_ex%~
      REPLACE_TEXTUALLY ~REPLACE_savingthrow_ex~         ~%savingthrow_ex%~
      REPLACE_TEXTUALLY ~REPLACE_savebonus_ex~           ~%savebonus_ex%~
      REPLACE_TEXTUALLY ~REPLACE_special_ex~             ~%special_ex%~
      REPLACE_TEXTUALLY ~REPLACE_match_resource_ex~      ~%match_resource_ex%~
      REPLACE_TEXTUALLY ~REPLACE_resource_ex~            ~%resource_ex%~

      REINCLUDE ~./inline/alter_effect_ex_macro_working.tph~

  END // end INNER_ACTION

  SPRINT SOURCE_FILE ~%o_SOURCE_FILE%~ // reset copy vars
  SPRINT SOURCE_RES  ~%o_SOURCE_RES%~
  SPRINT DEST_FILE   ~%o_DEST_FILE%~
  SPRINT DEST_RES    ~%o_DEST_RES%~

  PATCH_IF (BUFFER_LENGTH >= min_size) BEGIN // sanity check
    FOR (index = (0 - check_globals) ; index < abil_num ; ++index) BEGIN // we start at -1 for global effects
      PATCH_IF (index < 0) BEGIN // if loop through globals needed
        SET abil_fx_idx = 0  // start with effect 0 since we're in the global loop
        SET abil_type = "-1" // basically, ignore header type checks for global loop
      END ELSE BEGIN // otherwise normal ability
        READ_BYTE   (abil_off +        (abil_length * index)) abil_type
        SET counter_offset = (abil_off + 0x1e + (abil_length * index))
        READ_SHORT  (abil_off + 0x20 + (abil_length * index)) abil_fx_idx
      END
      READ_SHORT counter_offset counter // fx_num on global loop, otherwise abil_fx_num
      LAUNCH_PATCH_MACRO alter_effect_ex_macro_working
    END // end loop through effects on ability
  END // end ability loop

  PATCH_IF (alter = 0 && !silent) BEGIN
    PATCH_WARN "WARNING: no effects altered on %SOURCE_FILE% via ALTER_EFFECT_EX"
  END

  PATCH_IF (verbose && !silent) BEGIN
    READ_LONG 0x0c strref
    PATCH_IF ((strref > 0) AND (strref < 200000)) BEGIN
      READ_STRREF 0x0c name
    END ELSE BEGIN
      READ_STRREF 0x08 name
    END
    PATCH_PRINT "              ~%SOURCE_FILE%~   ~override~ // %name%, %alter% effect(s) altered via ALTER_EFFECT_EX"
  END

END

/////                                                  \\\\\
///// ALTER_HEADER_EX                                  \\\\\
/////                                                  \\\\\

// got tired of crappy ALTER_ITEM_HEADER and ALTER_SPELL_HEADER
DEFINE_PATCH_FUNCTION ALTER_HEADER_EX

  // defines what we're going to check
  INT_VAR multi_match         = 999
          verbose             = 0
          silent              = 0
          header              = "-1"

  // variables for finding the effect to match
          match_type        = "-1"
          match_location    = "-1"
          match_target      = "-1"
          match_target_num  = "-1"
          match_range       = "-1"
          match_speed       = "-1"
          match_projectile  = "-1"
          // spell headers only
          match_level       = "-1"
          // item headers only
          match_identify       = "-1"
          match_alt_dicesize   = "-1"
          match_launcher       = "-1"
          match_alt_dicenumber = "-1"
          match_alt_damage     = "-1"
          match_to_hit         = "-1"
          match_dicesize       = "-1"
          match_primary        = "-1"
          match_dicenumber     = "-1"
          match_secondary      = "-1"
          match_damage         = "-1"
          match_damage_type    = "-1"
          match_charges        = "-1"
          match_drained        = "-1"
          match_overhand       = "-1"
          match_backhand       = "-1"
          match_thrust         = "-1"
          match_arrow          = "-1"
          match_bolt           = "-1"
          match_bullet         = "-1"
          // flags at 0x26 (still item only)
          match_flag_strength      = "-1" // add strength bonus, bit0
          match_flag_break         = "-1" // breakable, bit1
          match_flag_str_damage    = "-1" // strength damage bonus, ee, bit2
          match_flag_str_to_hit    = "-1" // strength thac0 bonus, ee, bit3
          match_flag_sanctuary     = "-1" // break sanctuary, bit9
          match_flag_hostile       = "-1" // hostile, bit10
          match_flag_recharge      = "-1" // recharge after resting, bit11
          match_flag_bypass        = "-1" // bypass armor, bit16
          match_flag_keenedge      = "-1" // keen edge, bit17
          match_flag_backstab      = "-1" // tobex only, toggle backstab, bit25
          match_flag_noinvisible   = "-1" // tobex only, cannot target invisible, bit26

  // variables for the new effect
          type        = "-1"
          location    = "-1"
          target      = "-1"
          target_num  = "-1"
          range       = "-1"
          speed       = "-1"
          projectile  = "-1"
          // spell headers only
          level       = "-1"
          // item headers only
          identify       = "-1"
          alt_dicesize   = "-1"
          launcher       = "-1"
          alt_dicenumber = "-1"
          alt_damage     = "-1"
          to_hit         = "-1"
          dicesize       = "-1"
          primary        = "-1"
          dicenumber     = "-1"
          secondary      = "-1"
          damage         = "-1"
          damage_type    = "-1"
          charges        = "-1"
          drained        = "-1"
          overhand       = "-1"
          backhand       = "-1"
          thrust         = "-1"
          arrow          = "-1"
          bolt           = "-1"
          bullet         = "-1"
          // flags at 0x26
          flag_strength      = "-1" // add strength bonus, bit0
          flag_break         = "-1" // breakable, bit1
          flag_str_damage    = "-1" // strength damage bonus, ee, bit2
          flag_str_to_hit    = "-1" // strength thac0 bonus, ee, bit3
          flag_sanctuary     = "-1" // break sanctuary, bit9
          flag_hostile       = "-1" // hostile, bit10
          flag_recharge      = "-1" // recharge after resting, bit11
          flag_bypass        = "-1" // bypass armor, bit16
          flag_keenedge      = "-1" // keen edge, bit17
          flag_backstab      = "-1" // tobex only, toggle backstab, bit25
          flag_noinvisible   = "-1" // tobex only, cannot target invisible, bit26

  // same for match and new STR_VAR
  STR_VAR match_icon      = "SAME"
          icon            = "SAME"

          header_ex            = ~((header < 0) OR (header = index))~

          match_type_ex        = ~((match_type       = o_type)       OR (match_type < 0))~
          match_location_ex    = ~((match_location   = o_location)   OR (match_location < 0))~
          match_target_ex      = ~((match_target     = o_target)     OR (match_target < 0))~
          match_target_num_ex  = ~((match_target_num = o_target_num) OR (match_target_num < 0))~
          match_range_ex       = ~((match_range      = o_range)      OR (match_range < 0))~
          match_speed_ex       = ~((match_speed      = o_speed)      OR (match_speed < 0))~
          match_projectile_ex  = ~((match_projectile = o_projectile) OR (match_projectile < 0))~
          match_icon_ex        = ~ (("%match_icon%" STRING_COMPARE_CASE "%o_icon%" = 0) OR ("%match_icon%" STRING_COMPARE_CASE "SAME" = 0))~
          // spell headers only
          match_level_ex       = ~((match_level = o_level) OR (match_level < 0))~
          // item headers only
          match_identify_ex       = ~((match_identify       = o_identify)       OR (match_identify < 0))~
          match_alt_dicesize_ex   = ~((match_alt_dicesize   = o_alt_dicesize)   OR (match_alt_dicesize < 0))~
          match_launcher_ex       = ~((match_launcher       = o_launcher)       OR (match_launcher < 0))~
          match_alt_dicenumber_ex = ~((match_alt_dicenumber = o_alt_dicenumber) OR (match_alt_dicenumber < 0))~
          match_alt_damage_ex     = ~((match_alt_damage     = o_alt_damage)     OR (match_alt_damage < 0))~
          match_to_hit_ex         = ~((match_to_hit         = o_to_hit)         OR (match_to_hit < 0))~
          match_dicesize_ex       = ~((match_dicesize       = o_dicesize)       OR (match_dicesize < 0))~
          match_primary_ex        = ~((match_primary        = o_primary)        OR (match_primary < 0))~
          match_dicenumber_ex     = ~((match_dicenumber     = o_dicenumber)     OR (match_dicenumber < 0))~
          match_secondary_ex      = ~((match_secondary      = o_secondary)      OR (match_secondary < 0))~
          match_damage_ex         = ~((match_damage         = o_damage)         OR (match_damage < 0))~
          match_damage_type_ex    = ~((match_damage_type    = o_damage_type)    OR (match_damage_type < 0))~
          match_charges_ex        = ~((match_charges        = o_charges)        OR (match_charges < 0))~
          match_drained_ex        = ~((match_drained        = o_drained)        OR (match_drained < 0))~
          match_overhand_ex       = ~((match_overhand       = o_overhand)       OR (match_overhand < 0))~
          match_backhand_ex       = ~((match_backhand       = o_backhand)       OR (match_backhand < 0))~
          match_thrust_ex         = ~((match_thrust         = o_thrust)         OR (match_thrust < 0))~
          match_arrow_ex          = ~((match_arrow          = o_arrow)          OR (match_arrow < 0))~
          match_bolt_ex           = ~((match_bolt           = o_bolt)           OR (match_bolt < 0)) ~
          match_bullet_ex         = ~((match_bullet         = o_bullet)         OR (match_bullet < 0))~
          // flags at 0x26 (still item only)
          match_flag_strength_ex      = ~((match_flag_strength < 0) OR (match_flag_strength = (flags & BIT0)) OR (match_flag_strength > 0 AND (flags & BIT0) = BIT0))~ // add strength bonus, bit0
          match_flag_break_ex         = ~((match_flag_break < 0) OR (match_flag_break = (flags & BIT1)) OR(match_flag_break > 0 AND (flags & BIT1) = BIT1))~ // breakable, bit1
          match_flag_str_damage_ex    = ~((match_flag_str_damage < 0) OR (match_flag_str_damage = (flags & BIT2)) OR (match_flag_str_damage > 0 AND (flags & BIT2) = BIT2))~ // strength damage bonus, ee, bit2
          match_flag_str_to_hit_ex    = ~((match_flag_str_to_hit < 0) OR (match_flag_str_to_hit = (flags & BIT3)) OR (match_flag_str_to_hit > 0 AND (flags & BIT3) = BIT3))~ // strength thac0 bonus, ee, bit3
          match_flag_sanctuary_ex     = ~((match_flag_sanctuary < 0) OR (match_flag_sanctuary = (flags & BIT9)) OR (match_flag_sanctuary > 0 AND (flags & BIT9) = BIT9))~ // break sanctuary, bit9
          match_flag_hostile_ex       = ~((match_flag_hostile < 0) OR (match_flag_hostile = (flags & BIT10)) OR (match_flag_hostile > 0 AND (flags & BIT10) = BIT10))~ // hostile, bit10
          match_flag_recharge_ex      = ~((match_flag_recharge < 0) OR (match_flag_recharge = (flags & BIT11)) OR (match_flag_recharge > 0 AND (flags & BIT11) = BIT11))~ // recharge after resting, bit11
          match_flag_bypass_ex        = ~((match_flag_bypass < 0) OR (match_flag_bypass = (flags & BIT16)) OR (match_flag_bypass > 0 AND (flags & BIT16) = BIT16))~ // bypass armor, bit16
          match_flag_keenedge_ex      = ~((match_flag_keenedge < 0) OR (match_flag_keenedge = (flags & BIT17)) OR (match_flag_keenedge > 0 AND (flags & BIT17) = BIT17))~ // keen edge, bit17
          match_flag_backstab_ex      = ~((match_flag_backstab < 0) OR (match_flag_backstab = (flags & BIT25)) OR (match_flag_backstab > 0 AND (flags & BIT25) = BIT25))~ // tobex only, toggle backstab, bit25
          match_flag_noinvisible_ex   = ~((match_flag_noinvisible < 0) OR (match_flag_noinvisible = (flags & BIT26)) OR (match_flag_noinvisible > 0 AND (flags & BIT26) = BIT26))~ // tobex only, cannot target invisible, bit26

          type_ex        = "SAME"
          location_ex    = "SAME"
          target_ex      = "SAME"
          target_num_ex  = "SAME"
          range_ex       = "SAME"
          speed_ex       = "SAME"
          projectile_ex  = "SAME"
          icon_ex        = "SAME"
          // spell headers only
          level_ex       = "SAME"
          // item headers only
          identify_ex       = "SAME"
          alt_dicesize_ex   = "SAME"
          launcher_ex       = "SAME"
          alt_dicenumber_ex = "SAME"
          alt_damage_ex     = "SAME"
          to_hit_ex         = "SAME"
          dicesize_ex       = "SAME"
          primary_ex        = "SAME"
          dicenumber_ex     = "SAME"
          secondary_ex      = "SAME"
          damage_ex         = "SAME"
          damage_type_ex    = "SAME"
          charges_ex        = "SAME"
          drained_ex        = "SAME"
          overhand_ex       = "SAME"
          backhand_ex       = "SAME"
          thrust_ex         = "SAME"
          arrow_ex          = "SAME"
          bolt_ex           = "SAME"
          bullet_ex         = "SAME"
          // flags at 0x26
          flags_ex      = "SAME" // add strength bonus, bit0
BEGIN

  READ_ASCII 0x00 sig (3)
  SET abil_length = 0
  SET proceed = 0
  SET alter = 0
  PATCH_IF ("%sig%" STRING_COMPARE_CASE "ITM" = 0) BEGIN
    SET abil_length = 0x38
  END ELSE
  PATCH_IF ("%sig%" STRING_COMPARE_CASE "SPL" = 0) BEGIN
    SET abil_length = 0x28
  END
  PATCH_IF abil_length = 0 BEGIN
    PATCH_WARN ~WARNING: file type not recognized on %SOURCE_FILE% for ALTER_HEADER_EX macro.~
  END ELSE BEGIN

    SPRINT o_SOURCE_FILE ~%SOURCE_FILE%~ // preserve original copy vars
    SPRINT o_SOURCE_RES  ~%SOURCE_RES%~
    SPRINT o_DEST_FILE   ~%DEST_FILE%~
    SPRINT o_DEST_RES    ~%DEST_RES%~
    INNER_ACTION BEGIN

<<<<<<<<./inline/alter_header_ex_macro.tph

DEFINE_PATCH_MACRO alter_header_ex_macro_working BEGIN

      PATCH_IF (REPLACE_header_ex) BEGIN
        SET base = abil_off + (index * abil_length)
        READ_BYTE  (base + 0x00) o_type
        READ_BYTE  (base + 0x02) o_location
        READ_ASCII (base + 0x04) o_icon (8) NULL
        READ_BYTE  (base + 0x0c) o_target
        READ_BYTE  (base + 0x0d) o_target_num
        READ_SHORT (base + 0x0e) o_range
        READ_SHORT (base + pro_off) o_projectile
        PATCH_IF abil_length = 0x38 BEGIN
          // item headers only
          READ_BYTE  (base + 0x01) o_identify
          READ_BYTE  (base + 0x03) o_alt_dicesize
          READ_BYTE  (base + 0x10) o_launcher
          READ_BYTE  (base + 0x11) o_alt_dicenumber
          READ_BYTE  (base + 0x12) o_speed
          READ_BYTE  (base + 0x13) o_alt_damage
          READ_SHORT (base + 0x14) o_to_hit
          READ_BYTE  (base + 0x16) o_dicesize
          READ_BYTE  (base + 0x17) o_primary
          READ_BYTE  (base + 0x18) o_dicenumber
          READ_BYTE  (base + 0x19) o_secondary
          READ_SHORT (base + 0x1a) o_damage
          READ_SHORT (base + 0x1c) o_damage_type
          READ_SHORT (base + 0x22) o_charges
          READ_SHORT (base + 0x24) o_drained
          READ_LONG  (base + 0x26) o_flags
          READ_SHORT (base + 0x2c) o_overhand
          READ_SHORT (base + 0x2e) o_backhand
          READ_SHORT (base + 0x30) o_thrust
          READ_SHORT (base + 0x32) o_arrow
          READ_SHORT (base + 0x34) o_bolt
          READ_SHORT (base + 0x36) o_bullet
        END ELSE BEGIN
          READ_SHORT (base + 0x10) o_level
          READ_SHORT (base + 0x12) o_speed
        END
        // now check our header vs. the match variables
        PATCH_IF ((multi_match != 0) AND
                  (REPLACE_match_type_ex)       AND
                  (REPLACE_match_location_ex)   AND
                  (REPLACE_match_target_ex)     AND
                  (REPLACE_match_target_num_ex) AND
                  (REPLACE_match_range_ex)      AND
                  (REPLACE_match_speed_ex)      AND
                  (REPLACE_match_projectile_ex) AND
                  (REPLACE_match_icon_ex))
        BEGIN
          PATCH_IF (abil_length = 0x38) BEGIN  // item-specific checks
            PATCH_IF ((REPLACE_match_identify_ex)       AND
                      (REPLACE_match_alt_dicesize_ex)   AND
                      (REPLACE_match_launcher_ex)       AND
                      (REPLACE_match_alt_dicenumber_ex) AND
                      (REPLACE_match_alt_damage_ex)     AND
                      (REPLACE_match_to_hit_ex)         AND
                      (REPLACE_match_dicesize_ex)       AND
                      (REPLACE_match_primary_ex)        AND
                      (REPLACE_match_dicenumber_ex)     AND
                      (REPLACE_match_secondary_ex)      AND
                      (REPLACE_match_damage_ex)         AND
                      (REPLACE_match_damage_type_ex)    AND
                      (REPLACE_match_charges_ex)        AND
                      (REPLACE_match_drained_ex)        AND
                      (REPLACE_match_overhand_ex)       AND
                      (REPLACE_match_backhand_ex)       AND
                      (REPLACE_match_thrust_ex)         AND
                      (REPLACE_match_arrow_ex)          AND
                      (REPLACE_match_bolt_ex)           AND
                      (REPLACE_match_bullet_ex)         AND
                      (REPLACE_match_flag_strength_ex) AND
                      (REPLACE_match_flag_break_ex) AND
                      (REPLACE_match_flag_str_damage_ex) AND
                      (REPLACE_match_flag_str_to_hit_ex) AND
                      (REPLACE_match_flag_sanctuary_ex) AND
                      (REPLACE_match_flag_hostile_ex) AND
                      (REPLACE_match_flag_recharge_ex) AND
                      (REPLACE_match_flag_bypass_ex) AND
                      (REPLACE_match_flag_keenedge_ex) AND
                      (REPLACE_match_flag_backstab_ex) AND
                      (REPLACE_match_flag_noinvisible_ex)) BEGIN
              SET proceed = 1
            END
          END ELSE BEGIN // spell-specific checks
            PATCH_IF (REPLACE_match_level_ex) BEGIN
              SET proceed = 1
            END
          END
          PATCH_IF proceed BEGIN
            SET alter += 1
            SET multi_match -= 1
            PATCH_IF ("%type_ex%"       STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_BYTE  (base + 0x00) (REPLACE_type_ex)          END ELSE BEGIN
            PATCH_IF (type >= 0)       BEGIN WRITE_BYTE  (base + 0x00) type END END
            PATCH_IF ("%location_ex%"   STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_BYTE  (base + 0x02) (REPLACE_location_ex)      END ELSE BEGIN
            PATCH_IF (location >= 0)   BEGIN WRITE_BYTE  (base + 0x02) location END END
            PATCH_IF ("%target_ex%"     STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_BYTE  (base + 0x0c) (REPLACE_target_ex)        END ELSE BEGIN
            PATCH_IF (target >= 0)     BEGIN WRITE_BYTE  (base + 0x0c) target END END
            PATCH_IF ("%target_num_ex%" STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_BYTE  (base + 0x0d) (REPLACE_target_num_ex)    END ELSE BEGIN
            PATCH_IF (target_num >= 0) BEGIN WRITE_BYTE  (base + 0x0d) target_num END END
            PATCH_IF ("%range_ex%"      STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_SHORT (base + 0x0e) (REPLACE_range_ex)         END ELSE BEGIN
            PATCH_IF (range >= 0)      BEGIN WRITE_SHORT (base + 0x0e) range END END
            PATCH_IF ("%projectile_ex%" STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_SHORT (base + pro_off) (REPLACE_projectile_ex) END ELSE BEGIN
            PATCH_IF (projectile >= 0) BEGIN WRITE_SHORT (base + pro_off) projectile END END

            PATCH_IF ("%icon_ex%"       STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_ASCIIE (base + 0x04) REPLACE_icon_ex #8         END ELSE BEGIN
            PATCH_IF ("%icon%" STRING_COMPARE_CASE "SAME") BEGIN WRITE_ASCIIE (base + 0x04) ~%icon%~ #8 END END

            PATCH_IF abil_length = 0x38 BEGIN // item headers
              PATCH_IF ("%identify_ex%"       STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_BYTE  (base + 0x01) (REPLACE_identify_ex)       END ELSE BEGIN
              PATCH_IF (identify >= 0)       BEGIN WRITE_BYTE  (base + 0x01) identify       END END
              PATCH_IF ("%alt_dicesize_ex%"   STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_BYTE  (base + 0x03) (REPLACE_alt_dicesize_ex)   END ELSE BEGIN
              PATCH_IF (alt_dicesize >= 0)   BEGIN WRITE_BYTE  (base + 0x03) alt_dicesize   END END
              PATCH_IF ("%launcher_ex%"       STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_BYTE  (base + 0x10) (REPLACE_launcher_ex)       END ELSE BEGIN
              PATCH_IF (launcher >= 0)       BEGIN WRITE_BYTE  (base + 0x10) launcher       END END
              PATCH_IF ("%alt_dicenumber_ex%" STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_BYTE  (base + 0x11) (REPLACE_alt_dicenumber_ex) END ELSE BEGIN
              PATCH_IF (alt_dicenumber >= 0) BEGIN WRITE_BYTE  (base + 0x11) alt_dicenumber END END
              PATCH_IF ("%speed_ex%"          STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_BYTE  (base + 0x12) (REPLACE_speed_ex)          END ELSE BEGIN
              PATCH_IF (speed >= 0)          BEGIN WRITE_BYTE  (base + 0x12) speed          END END
              PATCH_IF ("%alt_damage_ex%"     STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_BYTE  (base + 0x13) (REPLACE_alt_damage_ex)     END ELSE BEGIN
              PATCH_IF (alt_damage >= 0)     BEGIN WRITE_BYTE  (base + 0x13) alt_damage     END END
              PATCH_IF ("%to_hit_ex%"         STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_SHORT (base + 0x14) (REPLACE_to_hit_ex)         END ELSE BEGIN
              PATCH_IF (to_hit >= 0)         BEGIN WRITE_SHORT (base + 0x14) to_hit         END END
              PATCH_IF ("%dicesize_ex%"       STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_BYTE  (base + 0x16) (REPLACE_dicesize_ex)       END ELSE BEGIN
              PATCH_IF (dicesize >= 0)       BEGIN WRITE_BYTE  (base + 0x16) dicesize       END END
              PATCH_IF ("%primary_ex%"        STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_BYTE  (base + 0x17) (REPLACE_primary_ex)        END ELSE BEGIN
              PATCH_IF (primary >= 0)        BEGIN WRITE_BYTE  (base + 0x17) primary        END END
              PATCH_IF ("%dicenumber_ex%"     STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_BYTE  (base + 0x18) (REPLACE_dicenumber_ex)     END ELSE BEGIN
              PATCH_IF (dicenumber >= 0)     BEGIN WRITE_BYTE  (base + 0x18) dicenumber     END END
              PATCH_IF ("%secondary_ex%"      STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_BYTE  (base + 0x19) (REPLACE_secondary_ex)      END ELSE BEGIN
              PATCH_IF (secondary >= 0)      BEGIN WRITE_BYTE  (base + 0x19) secondary      END END
              PATCH_IF ("%damage_ex%"         STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_SHORT (base + 0x1a) (REPLACE_damage_ex)         END ELSE BEGIN
              PATCH_IF (damage >= 0)         BEGIN WRITE_SHORT (base + 0x1a) damage         END END
              PATCH_IF ("%damage_type_ex%"    STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_SHORT (base + 0x1c) (REPLACE_damage_type_ex)    END ELSE BEGIN
              PATCH_IF (damage_type >= 0)    BEGIN WRITE_SHORT (base + 0x1c) damage_type    END END
              PATCH_IF ("%charges_ex%"        STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_SHORT (base + 0x22) (REPLACE_charges_ex)        END ELSE BEGIN
              PATCH_IF (charges >= 0)        BEGIN WRITE_SHORT (base + 0x22) charges        END END
              PATCH_IF ("%drained_ex%"        STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_SHORT (base + 0x24) (REPLACE_drained_ex)        END ELSE BEGIN
              PATCH_IF (drained >= 0)        BEGIN WRITE_SHORT (base + 0x24) drained        END END
              PATCH_IF ("%overhand_ex%"       STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_SHORT (base + 0x2c) (REPLACE_overhand_ex)       END ELSE BEGIN
              PATCH_IF (overhand >= 0)       BEGIN WRITE_SHORT (base + 0x2c) overhand       END END
              PATCH_IF ("%backhand_ex%"       STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_SHORT (base + 0x2e) (REPLACE_backhand_ex)       END ELSE BEGIN
              PATCH_IF (backhand >= 0)       BEGIN WRITE_SHORT (base + 0x2e) backhand       END END
              PATCH_IF ("%thrust_ex%"         STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_SHORT (base + 0x30) (REPLACE_thrust_ex)         END ELSE BEGIN
              PATCH_IF (thrust >= 0)         BEGIN WRITE_SHORT (base + 0x30) thrust         END END
              PATCH_IF ("%arrow_ex%"          STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_SHORT (base + 0x32) (REPLACE_arrow_ex)          END ELSE BEGIN
              PATCH_IF (arrow >= 0)          BEGIN WRITE_SHORT (base + 0x32) arrow          END END
              PATCH_IF ("%bolt_ex%"           STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_SHORT (base + 0x34) (REPLACE_bolt_ex)           END ELSE BEGIN
              PATCH_IF (bolt >= 0)           BEGIN WRITE_SHORT (base + 0x34) bolt           END END
              PATCH_IF ("%bullet_ex%"         STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_SHORT (base + 0x36) (REPLACE_bullet_ex)         END ELSE BEGIN
              PATCH_IF (bullet >= 0)         BEGIN WRITE_SHORT (base + 0x36) bullet         END END
              PATCH_IF ("%flags_ex%"         STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_LONG (base + 0x26) (REPLACE_flags_ex)         END ELSE BEGIN
                PATCH_IF (flag_strength = 0)    BEGIN WRITE_LONG (base + 0x26) (THIS &  `BIT0)  END
                PATCH_IF (flag_strength > 0)    BEGIN WRITE_LONG (base + 0x26) (THIS BOR BIT0)  END
                PATCH_IF (flag_break = 0)       BEGIN WRITE_LONG (base + 0x26) (THIS &  `BIT1)  END
                PATCH_IF (flag_break > 0)       BEGIN WRITE_LONG (base + 0x26) (THIS BOR BIT1)  END
                PATCH_IF (flag_str_damage = 0)  BEGIN WRITE_LONG (base + 0x26) (THIS &  `BIT2)  END
                PATCH_IF (flag_str_damage > 0)  BEGIN WRITE_LONG (base + 0x26) (THIS BOR BIT2)  END
                PATCH_IF (flag_str_to_hit = 0)  BEGIN WRITE_LONG (base + 0x26) (THIS &  `BIT3)  END
                PATCH_IF (flag_str_to_hit > 0)  BEGIN WRITE_LONG (base + 0x26) (THIS BOR BIT3)  END
                PATCH_IF (flag_hostile = 0)     BEGIN WRITE_LONG (base + 0x26) (THIS &  `BIT10) END
                PATCH_IF (flag_hostile > 0)     BEGIN WRITE_LONG (base + 0x26) (THIS BOR BIT10) END
                PATCH_IF (flag_recharge = 0)    BEGIN WRITE_LONG (base + 0x26) (THIS &  `BIT11) END
                PATCH_IF (flag_recharge > 0)    BEGIN WRITE_LONG (base + 0x26) (THIS BOR BIT11) END
                PATCH_IF (flag_bypass = 0)      BEGIN WRITE_LONG (base + 0x26) (THIS &  `BIT16) END
                PATCH_IF (flag_bypass > 0)      BEGIN WRITE_LONG (base + 0x26) (THIS BOR BIT16) END
                PATCH_IF (flag_keenedge = 0)    BEGIN WRITE_LONG (base + 0x26) (THIS &  `BIT17) END
                PATCH_IF (flag_keenedge > 0)    BEGIN WRITE_LONG (base + 0x26) (THIS BOR BIT17) END
                PATCH_IF (flag_backstab = 0)    BEGIN WRITE_LONG (base + 0x26) (THIS &  `BIT25) END
                PATCH_IF (flag_backstab > 0)    BEGIN WRITE_LONG (base + 0x26) (THIS BOR BIT25) END
                PATCH_IF (flag_noinvisible = 0) BEGIN WRITE_LONG (base + 0x26) (THIS &  `BIT26) END
                PATCH_IF (flag_noinvisible > 0) BEGIN WRITE_LONG (base + 0x26) (THIS BOR BIT26) END
              END
            END ELSE BEGIN // spell headers
              PATCH_IF ("%level_ex%"           STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_SHORT (base + 0x10) (REPLACE_level_ex) END ELSE BEGIN
              PATCH_IF (level >= 0) BEGIN WRITE_SHORT (base + 0x10) level END END
              PATCH_IF ("%speed_ex%"           STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_SHORT (base + 0x12) (REPLACE_speed_ex) END ELSE BEGIN
              PATCH_IF (speed >= 0) BEGIN WRITE_SHORT (base + 0x12) speed END END
            END
          END // proceed check
        END // mutual fields check
      END // header check

END

>>>>>>>>

      COPY ~./inline/alter_header_ex_macro.tph~ ~./inline/alter_header_ex_macro_working.tph~
        REPLACE_TEXTUALLY ~REPLACE_header_ex~                 ~%header_ex%~
        REPLACE_TEXTUALLY ~REPLACE_match_type_ex~             ~%match_type_ex%~
        REPLACE_TEXTUALLY ~REPLACE_match_location_ex~         ~%match_location_ex%~
        REPLACE_TEXTUALLY ~REPLACE_match_target_ex~           ~%match_target_ex%~
        REPLACE_TEXTUALLY ~REPLACE_match_target_num_ex~       ~%match_target_num_ex%~
        REPLACE_TEXTUALLY ~REPLACE_match_range_ex~            ~%match_range_ex%~
        REPLACE_TEXTUALLY ~REPLACE_match_speed_ex~            ~%match_speed_ex%~
        REPLACE_TEXTUALLY ~REPLACE_match_projectile_ex~       ~%match_projectile_ex%~
        REPLACE_TEXTUALLY ~REPLACE_match_icon_ex~             ~%match_icon_ex%~
        REPLACE_TEXTUALLY ~REPLACE_match_level_ex~            ~%match_level_ex%~
        REPLACE_TEXTUALLY ~REPLACE_match_identify_ex~         ~%match_identify_ex%~
        REPLACE_TEXTUALLY ~REPLACE_match_alt_dicesize_ex~     ~%match_alt_dicesize_ex%~
        REPLACE_TEXTUALLY ~REPLACE_match_launcher_ex~         ~%match_launcher_ex%~
        REPLACE_TEXTUALLY ~REPLACE_match_alt_dicenumber_ex~   ~%match_alt_dicenumber_ex%~
        REPLACE_TEXTUALLY ~REPLACE_match_alt_damage_ex~       ~%match_alt_damage_ex%~
        REPLACE_TEXTUALLY ~REPLACE_match_to_hit_ex~           ~%match_to_hit_ex%~
        REPLACE_TEXTUALLY ~REPLACE_match_dicesize_ex~         ~%match_dicesize_ex%~
        REPLACE_TEXTUALLY ~REPLACE_match_primary_ex~          ~%match_primary_ex%~
        REPLACE_TEXTUALLY ~REPLACE_match_dicenumber_ex~       ~%match_dicenumber_ex%~
        REPLACE_TEXTUALLY ~REPLACE_match_secondary_ex~        ~%match_secondary_ex%~
        REPLACE_TEXTUALLY ~REPLACE_match_damage_ex~           ~%match_damage_ex%~
        REPLACE_TEXTUALLY ~REPLACE_match_damage_type_ex~      ~%match_damage_type_ex%~
        REPLACE_TEXTUALLY ~REPLACE_match_charges_ex~          ~%match_charges_ex%~
        REPLACE_TEXTUALLY ~REPLACE_match_drained_ex~          ~%match_drained_ex%~
        REPLACE_TEXTUALLY ~REPLACE_match_overhand_ex~         ~%match_overhand_ex%~
        REPLACE_TEXTUALLY ~REPLACE_match_backhand_ex~         ~%match_backhand_ex%~
        REPLACE_TEXTUALLY ~REPLACE_match_thrust_ex~           ~%match_thrust_ex%~
        REPLACE_TEXTUALLY ~REPLACE_match_arrow_ex~            ~%match_arrow_ex%~
        REPLACE_TEXTUALLY ~REPLACE_match_bolt_ex~             ~%match_bolt_ex%~
        REPLACE_TEXTUALLY ~REPLACE_match_bullet_ex~           ~%match_bullet_ex%~
        REPLACE_TEXTUALLY ~REPLACE_match_flag_strength_ex~    ~%match_flag_strength_ex%~
        REPLACE_TEXTUALLY ~REPLACE_match_flag_break_ex~       ~%match_flag_break_ex%~
        REPLACE_TEXTUALLY ~REPLACE_match_flag_str_damage_ex~  ~%match_flag_str_damage_ex%~
        REPLACE_TEXTUALLY ~REPLACE_match_flag_str_to_hit_ex~  ~%match_flag_str_to_hit_ex%~
        REPLACE_TEXTUALLY ~REPLACE_match_flag_sanctuary_ex~   ~%match_flag_sanctuary_ex%~
        REPLACE_TEXTUALLY ~REPLACE_match_flag_hostile_ex~     ~%match_flag_hostile_ex%~
        REPLACE_TEXTUALLY ~REPLACE_match_flag_recharge_ex~    ~%match_flag_recharge_ex%~
        REPLACE_TEXTUALLY ~REPLACE_match_flag_bypass_ex~      ~%match_flag_bypass_ex%~
        REPLACE_TEXTUALLY ~REPLACE_match_flag_keenedge_ex~    ~%match_flag_keenedge_ex%~
        REPLACE_TEXTUALLY ~REPLACE_match_flag_backstab_ex~    ~%match_flag_backstab_ex%~
        REPLACE_TEXTUALLY ~REPLACE_match_flag_noinvisible_ex~ ~%match_flag_noinvisible_ex%~
        REPLACE_TEXTUALLY ~REPLACE_type_ex~                   ~%type_ex%~
        REPLACE_TEXTUALLY ~REPLACE_location_ex~               ~%location_ex%~
        REPLACE_TEXTUALLY ~REPLACE_target_ex~                 ~%target_ex%~
        REPLACE_TEXTUALLY ~REPLACE_target_num_ex~             ~%target_num_ex%~
        REPLACE_TEXTUALLY ~REPLACE_range_ex~                  ~%range_ex%~
        REPLACE_TEXTUALLY ~REPLACE_speed_ex~                  ~%speed_ex%~
        REPLACE_TEXTUALLY ~REPLACE_projectile_ex~             ~%projectile_ex%~
        REPLACE_TEXTUALLY ~REPLACE_icon_ex~                   ~%icon_ex%~
        REPLACE_TEXTUALLY ~REPLACE_level_ex~                  ~%level_ex%~
        REPLACE_TEXTUALLY ~REPLACE_identify_ex~               ~%identify_ex%~
        REPLACE_TEXTUALLY ~REPLACE_alt_dicesize_ex~           ~%alt_dicesize_ex%~
        REPLACE_TEXTUALLY ~REPLACE_launcher_ex~               ~%launcher_ex%~
        REPLACE_TEXTUALLY ~REPLACE_alt_dicenumber_ex~         ~%alt_dicenumber_ex%~
        REPLACE_TEXTUALLY ~REPLACE_alt_damage_ex~             ~%alt_damage_ex%~
        REPLACE_TEXTUALLY ~REPLACE_to_hit_ex~                 ~%to_hit_ex%~
        REPLACE_TEXTUALLY ~REPLACE_dicesize_ex~               ~%dicesize_ex%~
        REPLACE_TEXTUALLY ~REPLACE_primary_ex~                ~%primary_ex%~
        REPLACE_TEXTUALLY ~REPLACE_dicenumber_ex~             ~%dicenumber_ex%~
        REPLACE_TEXTUALLY ~REPLACE_secondary_ex~              ~%secondary_ex%~
        REPLACE_TEXTUALLY ~REPLACE_damage_ex~                 ~%damage_ex%~
        REPLACE_TEXTUALLY ~REPLACE_damage_type_ex~            ~%damage_type_ex%~
        REPLACE_TEXTUALLY ~REPLACE_charges_ex~                ~%charges_ex%~
        REPLACE_TEXTUALLY ~REPLACE_drained_ex~                ~%drained_ex%~
        REPLACE_TEXTUALLY ~REPLACE_overhand_ex~               ~%overhand_ex%~
        REPLACE_TEXTUALLY ~REPLACE_backhand_ex~               ~%backhand_ex%~
        REPLACE_TEXTUALLY ~REPLACE_thrust_ex~                 ~%thrust_ex%~
        REPLACE_TEXTUALLY ~REPLACE_arrow_ex~                  ~%arrow_ex%~
        REPLACE_TEXTUALLY ~REPLACE_bolt_ex~                   ~%bolt_ex%~
        REPLACE_TEXTUALLY ~REPLACE_bullet_ex~                 ~%bullet_ex%~
        REPLACE_TEXTUALLY ~REPLACE_flags_ex~                  ~%flags_ex%~

        REINCLUDE ~./inline/alter_header_ex_macro_working.tph~

    END // end INNER_ACTION

    SPRINT SOURCE_FILE ~%o_SOURCE_FILE%~ // reset copy vars
    SPRINT SOURCE_RES  ~%o_SOURCE_RES%~
    SPRINT DEST_FILE   ~%o_DEST_FILE%~
    SPRINT DEST_RES    ~%o_DEST_RES%~

    SET pro_off = abil_length = 0x38 ? 0x2a : 0x26
    READ_LONG   0x64 abil_off
    READ_SHORT  0x68 abil_num
    FOR (index = 0 ; index < abil_num ; ++index) BEGIN
      LAUNCH_PATCH_MACRO alter_header_ex_macro_working
    END // for loop
  END // abil_length check

  PATCH_IF (alter = 0 && !silent) BEGIN
    PATCH_WARN "WARNING: no headers altered on %SOURCE_FILE% via ALTER_HEADER_EX"
  END

  PATCH_IF (verbose && !silent) BEGIN
    READ_LONG 0x0c strref
    PATCH_IF ((strref > 0) AND (strref < 200000)) BEGIN
      READ_STRREF 0x0c name
    END ELSE BEGIN
      READ_STRREF 0x08 name
    END
    PATCH_PRINT "              ~%SOURCE_FILE%~   ~override~ // %name%, %alter% header(s) altered via ALTER_HEADER_EX"
  END

END
